#+TITLE: snvec-R
#+AUTHOR: Ilja J. Kocken
#+EMAIL: ikocken@hawaii.edu
written by Ilja J. Kocken [[https://orcid.org/0000-0003-2196-8718][orcid:0000-0003-2196-8718]]

#+PROPERTY: header-args:R  :session *R:snvec-R* :exports both :results output :eval no-export

* snvec-R
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
This project aims to make the =snvec= C-code more readily available to R-users.

snvec: Pre-computed Precession-Tilt solutions and C code.

** setup
*** citation
#+begin_quote
When using snvec, cite as:

A deep-time dating tool for paleo-applications utilizing obliquity
and precession cycles: The role of dynamical ellipticity and tidal
dissipation, Richard E. Zeebe and Lucas J. Lourens, Paleoceanography
and Paleoclimatology, 2022.

Richard E. Zeebe
School of Ocean and Earth
Science and Technology
University of Hawaii at Manoa
1000 Pope Road, MSB 504
Honolulu, HI 96822, USA
email: zeebe@soest.hawaii.edu
#+end_quote

*** load libraries
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 09:14]
:END:
#+begin_src R :results none
  library(tidyverse)
  # we use dplyr and ggplot2 mostly
  library(deSolve)
  # make sure you have `glue` for the info messages
#+end_src

*** SOME reduce dependencies
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 12:23]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-31 Fri 12:23]
:END:

*** set the version
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:32]
:END:
#+begin_src R
 VER <- "snvec.r VERSION: 3.7.5 2023-03-29"
#+end_src

#+RESULTS:

*** global variables
#+begin_src R
  AU <- 1.49597870700e11 # m
  GM <- 1.32712440041e20 # m3/s2
  OM <- 7.292115e-5      # 1/s EarthRot
  R0 <- 3.8440e8         # m Moon R0
  GK <- 0.9925194        # Kinoshita75,77
  ED0 <- 0.0032738134    # DynEll (C-A)/C
  FGP <- 0.99961908
  AU3 <- AU * AU * AU
  R03 <- R0 * R0 * R0
  # no need to define pi in R
  R2D <- 180. / pi       # radians to deg

  D2S <- 3600. * 24.
  Y2D <- 365.25
  KY2D <- 1.e3 * Y2D

  # set default Ed, Td
  ED <- 1.0000         # set factor 1.0
  TD <- 0.0000         # set factor 0.0

  # mass ratios
  MSEL <- 328900.5596      # MS/(ME+ML)
  MEL <- 81.300568         # ME/ML
  MLS <- 1. / (MSEL * (1 + MEL)) # ML/MS
  # K0, beta0 for torques
  K0 <- (3. / 2.) * GM * ED0 * ED / (OM * AU3)
  K0D <- K0 * D2S          # 1/s => 1/d */
  BET0 <- GK * MLS * AU3 / R03
  K0B0 <- K0D * (1. + BET0)
  # Moon mean motion
  N0 <- sqrt(GM / MSEL / R03)
  NW0 <- (N0 / OM) # ratio (n/om)_0
  # Tidal dissipation Quinn91 Eqs. (3, 11)
  # NDN = (dndt/n)_0, WDW = (domdt/om)_0
  NDN <- (-4.6e-18 * D2S * TD) # 1/s => 1/d
  WDW <- (51. * NDN * NW0)     # Lambeck80
  # tidal effect on obliquity
  UEPSDOT <- -4.17e-19

  # SunRot Angles (Transform to HCI)
  OMT <- 75.5940
  INCT <- 7.155
  EP0 <- 23.439291111111110 # Obliquity t0
#+end_src

#+RESULTS:

** read in the orbital solution ZB18a
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
[[file:snvec-3.7.5/ems-plan3.dat]]

the top of the file has some lines specifying which columns were used
0  7  8  9  12 10 11 15

#+begin_src R :results value :colnames yes
  library(readr)

  dat <- read_table("snvec-3.7.5/ems-plan3.dat",
                    comment = "#",
                    skip = 3,
                    col_names = c(
                      "time",              # 0-Time (=Epoch)
                      ## "x1", "x2", "x3", # 1-3
                      ## "v1", "v2", "v3", # 4-6
                      "semimajor_axis",    # 7-SemiMajorAxis
                      "eccentricity",      # 8
                      "inclination",       # 9
                      "long_periapse",     # 12
                      ## "time_periapse",  # 13
                      "long_ascend_node",  # 10
                      "arg_periapse",      # 11
                      ## "peri_distance",  # 12
                      "mean_anomaly"#      # 15
                      ## "true_anomaly",   # 16
                      ## "mean_longitude", # 17
                      ## "true_longitude", # 18
                      ## "mean_latitude",  # 19
                      ## "true_latitude",  # 20
                      ## "mass",           # 21
                      ## "enc_radius",     # 22
                      ## "capt_radius",    # 23
                      ## "id_tag",         # 24
                      ## "jac_index"       # 25
                    ))

  head(dat) |> round(2)
#+end_src

#+RESULTS:
|    time | semimajor_axis | eccentricity | inclination | long_periapse | long_ascend_node | arg_periapse | mean_anomaly |
|---------+----------------+--------------+-------------+---------------+------------------+--------------+--------------|
|       0 |              1 |         0.02 |        7.15 |         27.32 |              180 |      -152.68 |        -2.45 |
| -146100 |              1 |         0.02 |        7.15 |         26.12 |          -179.59 |      -154.29 |         1.27 |
| -292200 |              1 |         0.02 |        7.14 |         24.69 |          -179.17 |      -156.14 |         5.22 |
| -438300 |              1 |         0.02 |        7.12 |         23.67 |          -178.75 |      -157.58 |         8.75 |
| -584400 |              1 |         0.02 |        7.11 |         22.12 |          -178.34 |      -159.54 |         12.8 |
| -730500 |              1 |         0.02 |         7.1 |            21 |          -177.92 |      -161.08 |        16.45 |

*** rename some of the names in dat
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:14]
:END:
to make the naming consistent with the C code
#+begin_src R
  dat <- dat |>
    tidylog::rename(
      t  = time,
      aa = semimajor_axis,
      ee = eccentricity,
      inc = inclination,
      lph = long_periapse,
      lan = long_ascend_node,
      arp = arg_periapse,
      mna = mean_anomaly)
#+end_src

#+RESULTS:
: rename: renamed 8 variables (t, aa, ee, inc, lph, â€¦)

** input parameters of the final function/program
*** set the inputs
#+begin_src R
  ed <- 1
  td <- 0
  tend <- -1e3 # quick tester, defaults for C
  ## tend <- -1e5 # full solution
#+end_src

#+RESULTS:

*** check inputs
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 11:56]
:END:
#+begin_src R
  if (tend >= 0) {
    stop(glue::glue("`tend` must be < 0, but tend = {tend}"))
  }
  if (tend < min(dat$t / KY2D)) {
    stop(glue::glue("`tend` must be > the orbital solution {min(dat$t)/KY2D}, but tend = {tend}."))
  }
#+end_src

#+RESULTS:

*** message user about inputs
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:31]
:END:
#+begin_src R
  message(glue::glue("This is {VER}"))
  message("Richard E. Zeebe")
  message("Ilja J. Kocken")
  message("Integration parameters:")
  message(glue::glue(" tend = {tend} kyr"))
  message(glue::glue(" Ed = {ed}"))
  message(glue::glue(" Td = {td}"))
#+end_src

#+RESULTS:
: This is snvec.r VERSION: 3.7.5 2023-03-29
: Richard E. Zeebe
: Ilja J. Kocken
: Integration parameters:
:  tend = -1000 kyr
:  Ed = 1
:  Td = 0

** prepare variables
*** calculate helper parameters
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fvei()][fvei()]]
helper parameters as new columns of dat
#+begin_src R
  dat <- dat |>
    mutate(age = - t / KY2D, .after = t) |>
    mutate(hh = ee * sin(lph / R2D),
           kk = ee * cos(lph / R2D),
           pp = 2 * sin(0.5 * inc / R2D) * sin(lan / R2D),
           qq = 2 * sin(0.5 * inc / R2D) * cos(lan / R2D),
           cc = cos(inc / R2D),
           dd = cos(inc / R2D / 2),
           ## /* nn <- nvec(t): normal to orbit */
           nnx = sin(inc / R2D) * sin(lan / R2D),
           nny = -sin(inc / R2D) * cos(lan / R2D),
           nnz = cos(inc / R2D))
#+end_src

#+RESULTS:

*** SOME I've just changed nnx nny nnz to a single list of vectors nn
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 12:26]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-03-30 Thu 12:34]
:END:
#+begin_src R :eval never
    ## rowwise() |> # this makes it very slow already, without vectors
  # SOME: do it as a list of vectors in stead?
           ## nn = list(c(sin(inc / R2D) * sin(lan / R2D),
           ##             -sin(inc / R2D) * cos(lan / R2D),
           ##             cos(inc / R2D))))
#+end_src

*** COMMENT plot orbital solution input
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 14:20]
:END:
*** ee
#+begin_src R :results output graphics file :file input_ee.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = ee)) +
   labs(x = "Age (Ma)", y = "Eccentricity") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:input_ee.png]]

*** inc
#+begin_src R :results output graphics file :file input_inc.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = inc)) +
   labs(x = "Age (Ma)", y = "Inclination") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:input_inc.png]]

*** lph
#+begin_src R :results output graphics file :file input_lph.png :width 700
  dat |>
   ggplot(aes(x = age / 1e3, y = lph)) +
   labs(x = "Age (Ma)", y = "Long Periapse") +
   scale_x_reverse() +
   xlim(c(1, 0)) +
   geom_line() +
   geom_line(aes(y = unwrap(lph)), col = "red") +
   coord_cartesian(ylim=c(-3.1e6,200))
#+end_src

#+RESULTS:
[[file:input_lph.png]]

*** lan
#+begin_src R :results output graphics file :file input_lan.png :width 700
  dat |>
   ggplot(aes(x = age / 1e3, y = lan)) +
   labs(x = "Age (Ma)", y = "Long Ascending Node") +
   scale_x_reverse() +
   xlim(c(1, 0)) +
   geom_line() +
   geom_line(aes(y = unwrap(lan)), col = "red") +
   coord_cartesian(ylim=c(-2e4, 5))
#+end_src

#+RESULTS:
[[file:input_lan.png]]

*** h, k, p, q
#+begin_src R :results output graphics file :file input_hkpq.png :width 700 :eval never
  dat |>
    select(age, hh, kk, pp, qq, cc, dd) |>
    pivot_longer(hh:dd) |>
    ggplot(aes(x = age / 1e3, y = value)) +
    labs(x = "Age (Ma)") +
    scale_x_reverse() +
    xlim(c(1, 0)) +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line()
#+end_src

#+RESULTS:
[[file:input_hkpq.png]]

*** calculate global vars ndn, wdw, k0d from Td and Ed
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:40]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fedtd() ][fedtd()]]
#+begin_src R
  # as a function of ed, td
  k0d <- ((3 / 2) * GM * ED0 * ed / (OM * AU3)) * D2S # 1/s => 1/d
  k0b0 <- k0d * (1 + BET0)
  ndn <- -4.6e-18 * D2S * td # 1/s => 1/d
  wdw <- 51 * ndn * NW0 # Lambeck80, see PTman
  tdg <- td # global Td
  dts <- dat$t[2] - dat$t[1] # difference in time
#+end_src

#+RESULTS:

*** the euler transformation
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 15:14]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== euler()][euler()]]
#+begin_src R
  #' Euler transformation.
  #'
  #' s* = A * s, where spin vector s is in invariable plane and s* in instant
  #' orbit plane. inv = 1 gives inverse transformation (A^-1 = A' =
  #' transpose(A)).
  #'
  #' @param s The vector to be transformed.
  #' @param inc  The inclination.
  #' @param lan  The Long Ascending Node
  #' @param inv  Invert the output.
  euler <- function(s, inc, lan, inv = FALSE) {
    a <- matrix(c( cos(lan), sin(lan), 0,
                  -cos(inc) * sin(lan), cos(inc) * cos(lan), sin(inc),
                   sin(inc) * sin(lan), -sin(inc) * cos(lan), cos(inc)),
                 ncol = 3,
                 byrow = TRUE)
    if (inv) a <- t(a)
    a %*% s
  }
#+end_src

#+RESULTS:

*** initial values for the spin vector s
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:04]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== finits() ][finits()]]

use finits to get initial conditions in transformed ECLIPJ2000

#+begin_src R
  omt <- OMT / R2D
  inct <- INCT / R2D
  ep0 <- EP0 / R2D
  cs <- cos(ep0)

  # first row of nn -> needs to be a vector
  # orbit normal at t=0
  ninit <- dat |>
    filter(t == 0) |>
    select(nnx, nny, nnz) |>
    as.matrix() |>
    as.vector()

  # transform n => n'
  np <- euler(ninit, inct, omt, TRUE)

  # solve quadratic equation for s0'y
  a <- np[2] * np[2] + np[3]*np[3]
  b <- -2 * cs * np[2]
  c <- cs*cs - np[3] * np[3]

  s0p <- c(NA, NA, NA)
  s0p[2] <- (-b + sqrt(b*b-4*a*c))/(2*a)
  s0p[3] <- sqrt(1-s0p[2]*s0p[2])
  s0p[1] <- 0
  as.matrix(s0p)

  # transform s0' to s0
  s0 <- euler(s0p, inct, omt, 0)
#+end_src

#+RESULTS:
:           [,1]
: [1,] 0.0000000
: [2,] 0.3977784
: [3,] 0.9174815

*** set the deSolve state
#+begin_src R
  state <- c(sx = s0[1],
             sy = s0[2],
             sz = s0[3])
#+end_src

#+RESULTS:

*** define deSolve parameters
#+begin_src R
  parameters <- c(
    ed = ed,
    td = td,
    k0d = k0d,
    wdw = wdw,
    ndn = ndn)
#+end_src

#+RESULTS:

*** our inputs change as a function of time, so we need a function to describe them
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 09:06]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== qinterp()][qinterp()]]

**** using approxfun
http://desolve.r-forge.r-project.org/ has an article on time-varying inputs
we can use approxfun to generate a function that approximates =col= for timestep t.

#+begin_src R :eval never
  old_qinterp <- function(dat, col = ee) {
    dat |>
     select(t, {{col}}) |>
     approxfun(rule = 2)
  }
#+end_src

#+RESULTS:

this is very slow though, so we use a quicker interpolation algorithm, closer
to how Richard does it in C.

**** implement qinterp similar to the C-routine
#+begin_src R
  ##' qinterp
  ##'
  ##' @param y The vector to interpolate.
  ##' @param ds The difference in timestep in the astronomical solution.
  ##' @param dx The difference between the current timestep and the timestep in the astronomical solution.
  ##' @param m The index variable of the current position in the astronomical solution.
  ##' @return The vector of interpolated results
  qinterp <- function(y, ds, dx, m) {
    yi <- y[m]; dy <- 0; dsa <- abs(ds); dxa <- abs(dx); mm <- 1L
    ## if (dxa > 0) {
      mm <- m - as.integer(sign(dx))
      dy <- y[mm] - y[m]
      yi <- yi + dy * dxa / dsa
    ## }
    return(yi)
  }
#+end_src

#+RESULTS:

**** double-check that the interpolation is working
#+begin_src R :eval never
  input <- dat |>
    select(time, ee) |>
    approxfun(rule = 2)

  # this creates a function that we can call from within the other function
  # e.g.
  input(1.42 * KY2D)
#+end_src

#+RESULTS:
: [1] 0.01670545

> I created the approxfun function

#+begin_src R :results output graphics file :file qinterp_test.png
  t <- -.45 * KY2D
  m <- min(round(abs(t / dts) + 1), nrow(dat))
  dx <- t - dat$t[m];

  dat |>
    slice(1:3) |>
    ggplot(aes(x = t, y = lph)) +
    geom_line() +
    geom_point() +
    annotate("point",
             x = t,
             ## y = qinterp(dat, lph)(-.45 * KY2D),
             y = qinterp(dat$lph, dts, dx, m),
             col = "red")
#+end_src

#+RESULTS:
[[file:qinterp_test.png]]

**** time how long it takes
#+begin_src R :results output graphics file :file benchmark_qinterp.png :width 800 :eval never
  bm_qi <- microbenchmark::microbenchmark(
                  old_qinterp(dat, qq)(-146100),
                  qinterp(dat$qq,-146100,-48700,4)
                  )
  autoplot(bm_qi)
#+end_src

#+RESULTS:
[[file:benchmark_qinterp.png]]

yeah that's ... 4 orders of magnitude faster...


** solve the system of ODEs
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:11]
:END:

*** the differential equations
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 11:56]
:END:
see [[derivs]]

#+begin_src R
  # derivatives. RHS of DEQs for spin vector s = y
  eqns <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {

      # K0, beta0 changing with Td, Ed
      ## kb <- k0d * (1 + 1 * wdw * t) * (1 + BET0 * (1 + 2 * ndn * t))
      # we leave qinterp on, so ff is used for kb

      # set time index of solution
      ## t <- dat$t[5] # e.g.
      m <- min(round(abs(t / dts) + 1), nrow(dat))

      # for interpolation we can use t directly
      ## if (qinterp) {
      # we call on global dat for now
      ## qqi <- qinterp(dat, qq)(t)
      ## ppi <- qinterp(dat, pp)(t)
      ## cci <- qinterp(dat, cc)(t)
      ## ddi <- qinterp(dat, dd)(t)
      ## }
      dx <- t - dat$t[m];
      qqi <- qinterp(dat$qq,dts,dx,m)
      ppi <- qinterp(dat$pp,dts,dx,m)
      cci <- qinterp(dat$cc,dts,dx,m)
      ddi <- qinterp(dat$dd,dts,dx,m)

      # 1/(1-e^2)^3/2 term
      # add interpolation
      ## hhi <- qinterp(dat$hh,dts,dx,m)
      ## kki <- qinterp(dat$kk,dts,dx,m)
      ## ff <- (1 - hhi * hhi - kki * kki)

      # shouldn't I also interpolate hh and kk? -> see above
      ff <- (1 - dat$hh[m] * dat$hh[m] - dat$kk[m] * dat$kk[m])
      # i've tried both, gives identical results if I use the prescribed timesteps.
      # they're also equally fast! so let's go with my own which I think is better.
      # it might be the cause of numerical diffs between C and R? try without again

      ff <- 1 / sqrt(ff*ff*ff)
      kb <- k0d * (1 + 1 * wdw * t) * (ff + BET0 * (1 + 2 * ndn * t))

      fac <- FGP * kb * (ddi * (ppi * sx - qqi * sy) + cci * sz)

      dX <-  fac * ( cci * sy + ddi * qqi * sz)
      dY <-  fac * (-cci * sx + ddi * ppi * sz)
      dZ <- -fac * ( qqi * sx + ppi * sy) * ddi

      # EPSDOT
      ## dotab = s[1]*nn[1][m]+s[2]*nn[2][m]+s[3]*nn[3][m];
      ## tmp = tdg*EPSDOT*D2S/sqrt(1.-dotab*dotab);
      ## yp[1] += tmp*(nn[1][m] - dotab*s[1]);
      ## yp[2] += tmp*(nn[2][m] - dotab*s[2]);
      ## yp[3] += tmp*(nn[3][m] - dotab*s[3]);

      list(c(dX, dY, dZ))
    }) # end 'with(as.list( ...
  }
#+end_src

#+RESULTS:


*** timesteps to report
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:08]
:END:
:LOGBOOK:
- Note taken on [2023-03-31 Fri 16:55] \\
  i just changed this so from by = 1 * KY2D to 0.2*KY2D making it 5 times more high-res to see if that's the cause of the discrepancy
:END:

**** a linear sequence of steps
#+begin_src R
  ## EPSLVR <- 1.e-7 # accuracy 1e-7 2.2e-7/8.5e-7 La
  times <- seq(0, tend * KY2D,
               ## length.out = 2523L # the length of the C-output
               by = - 0.4 * KY2D # ~ the average diff in the C-output
               # snv_sout$time |> diff() |> median() = 0.396013
               )
#+end_src

#+RESULTS:

**** let's use the exact same timesteps as the C-routine
[[file:~/SurfDrive/Postdoc1/prj/2023-03-23_snvec-R/README.org::*inspect the c output][inspect the c output]]

#+begin_src R :eval never
  times <- snv_sout$time * KY2D
  # what if I offset it by a few steps?
  ## times <- times - 0.1 * KY2D
  # it gets offset again! :O
#+end_src

#+RESULTS:
*** DONE use qinterp on hh and kk as well
CLOSED: [2023-04-01 Sat 11:10]
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 12:39]
:END:

*** solve it
[[file:snvec-3.7.5/snvec-3.7.5.c::%%% solver][odeint()]]
#+begin_src R
  print(system.time(
  ## microbenchmark::microbenchmark(
    out <- ode(y = state,
               times = times,
               func = eqns,
               parms = parameters,
               method =
                 ## "lsoda"# = default, chooses stiff/nonstiff automatically starting non-stiff
                 # "ode23" # = non-stiff, variable time-step
                 ## "ode45" # = stiff, variable time-step
               # radau #= stiff/non-stiff
               "bdf", # = stiff
               ## "daspk", # = very stiff
               # play around with machine precision: default is 1e-6
               ## rtol = 1e-5, atol = 1e-5 # rougher = faster?
               rtol = 1e-7, atol = 1e-7 # based on EPSLVR
               ## rtol = 1e-12, atol = 1e-12
               )
  ))
  ## )
#+end_src

#+RESULTS:
:    user  system elapsed
:   0.223   0.000   0.224

*** older results notes
| date             |     user |  system |  elapsed | method |  steps | notes                                |                           |
|------------------+----------+---------+----------+--------+--------+--------------------------------------+---------------------------|
| [2023-03-30 Thu] |  361.986 |   0.213 |  364.353 | rk4    |   1000 |                                      |                           |
| [2023-03-30 Thu] |  334.800 |   0.081 |  336.341 | rk4    |   1000 | no error                             |                           |
| [2023-03-31 Fri] | 2927.945 | 187.784 | 3136.222 | ode23  |   5001 | with interpolation of hh kk          |                           |
| [2023-04-01 Sat] | 3649.884 | 186.344 | 3853.946 | ode45  |   5001 |                                      |                           |
| [2023-04-01 Sat] |  366.281 |  13.585 |  381.437 | bdf    |   2523 | same number of steps as in C-routine |                           |
| [2023-04-02 Sun] |  320.980 |  12.352 |  334.679 | daspk  |   2523 |                                      |                           |
| [2023-04-02 Sun] |  792.366 |  26.664 |  824.907 | lsoda  |   2523 | default                              |                           |
| [2023-04-03 Mon] |  242.316 |  25.936 |  269.344 | daspk  |   2523 | qinterp closer to C                  |                           |
| [2023-04-03 Mon] |    0.181 |   0.000 |    0.182 | daspk  |   2523 | qinterp fix!                         |                           |
| [2023-04-03 Mon] |    0.128 |   0.001 |    0.128 | daspk  |   2523 | same timesteps as C                  |                           |
| [2023-04-03 Mon] |   15.517 |   0.000 |   15.556 | daspk  |   2501 | linear timestep + a/rtol = 1e-10     |                           |
| [2023-04-03 Mon] |    0.147 |   0.000 |    0.147 | bdf    |   2501 | flipped times                        |                           |
| [2023-04-03 Mon] |   29.969 |   0.000 |   30.073 | bdf    |   2501 | rtol = atol = 1e-12                  |                           |
| [2023-04-03 Mon] |   18.229 |   0.026 |   18.338 | bdf    | 250001 | bdf                                  | rtol = 1e-7, full 100 Myr |

#+begin_src R
  lubridate::as.duration(c(0.147, 100, 500, 1000, 2000, 3000))
#+end_src

#+RESULTS:
: [1] "0.147s"                 "100s (~1.67 minutes)"   "500s (~8.33 minutes)"   "1000s (~16.67 minutes)" "2000s (~33.33 minutes)" "3000s (~50 minutes)"

*** benchmarks using microbenchmark
:  out <- ode(y = state, times = times, func = eqns, parms = parameters,      method = "bdf")
:       min       lq    mean   median       uq      max neval
:  130.6327 134.4619 143.1704 137.2702 142.9504 279.2405   100 # daspk
:  125.8702 133.1821 140.109  134.8777 139.3579 188.0364   100 # bdf
:  213.6866 226.2011 241.949 232.1017 249.3671 401.4864    100 # lsoda
:  702.615  712.545  883.7992 715.33  724.0765 12602.84    100 # ode45

*** COMMENT save the output
this is no longer needed now that I have implemented the fast qinterp algorithm and it solves it almost instantly
#+begin_src R :eval never
  ## write_rds(out, "out/2023-03-30_out.rds") # rk4, 1000 steps
  ## write_rds(out, "out/2023-03-31_out.rds") # ode23 5001 steps, intended for non-stiff problems!
  ## write_rds(out, "out/2023-04-01_out-ode45.rds") # ode45 5001 steps
  ## write_rds(out, "out/2023-04-01_out-bdf.rds")   # bdf stiff 2523 steps
  ## write_rds(out, "out/2023-04-02_out-daspk.rds")    # daspk stiff 2523 steps
  ## write_rds(out, "out/2023-04-02_out-lsoda.rds")    # lsoda stiff 2523 steps
  ## write_rds(out, "out/2023-04-03_out-qinterp.rds")    # daspk 2523 steps but with qinterp closer to c-implementation (???)
  ## write_rds(out, "out/2023-04-03_out-qinterp2.rds")    # daspk 2523 qinterp fix
  ## write_rds(out, "out/2023-04-03_out-times.rds")    # daspk 2523 same timestep as C = IDENTICAL!
  ## write_rds(out, "out/2023-04-03_out-tol.rds")    # daspk 2523 atol rtol = 1e-10
  ## write_rds(out, "out/2023-04-03_out-tollow.rds")    # daspk 2523 atol rtol = 1e-10
  ## write_rds(out, "out/2023-04-03_out-bdf.rds")    # bdf 2523 atol rtol = 1e-10
  ## write_rds(out, "out/2023-04-03_out-works.rds")    # bdf 2501 time in different order
  write_rds(out, "out/2023-04-04_out-tol.rds")    # bdf 2501 rtol = atol = 1e-12
#+end_src

#+RESULTS:

*** COMMENT read in the main result
#+begin_src R :eval never
  out <- read_rds("out/2023-04-03_out-works.rds")
#+end_src

#+RESULTS:

** analyse the ODE solver for problems
:PROPERTIES:
:CREATED:  [2023-04-03 Mon 14:38]
:END:
#+begin_src R
  diagnostics(out)
#+end_src

#+RESULTS:
#+begin_example

--------------------
lsode return code
--------------------

  return code (idid) =  2
  Integration was successful.

--------------------
INTEGER values
--------------------

  1 The return code : 2
  2 The number of steps taken for the problem so far: 2539
  3 The number of function evaluations for the problem so far: 3194
  5 The method order last used (successfully): 5
  6 The order of the method to be attempted on the next step: 5
  7 If return flag =-4,-5: the largest component in error vector 0
  8 The length of the real work array actually required: 58
  9 The length of the integer work array actually required: 23
 14 The number of Jacobian evaluations and LU decompositions so far: 132

--------------------
RSTATE values
--------------------

  1 The step size in t last used (successfully): -146100
  2 The step size to be attempted on the next step: -146100
  3 The current value of the independent variable which the solver has reached: -365307400
  4 Tolerance scale factor > 1.0 computed when requesting too much accuracy: 0
#+end_example

** COMMENT read in previous results
#+begin_src R :eval never
  make_combinable <- function(dat, method) {
    dat |>
     as_tibble() |>
     mutate(across(time:sz, as.double)) |>
     mutate(method = method)
  }
#+end_src

#+RESULTS:

#+begin_src R :eval never
  ## out <- read_rds("out/2023-03-29_out.rds")
  rk4 <- read_rds("out/2023-03-30_out.rds") |> make_combinable("rk4") # rk4, 1000 steps
  ode23 <- read_rds("out/2023-03-31_out.rds") |> make_combinable("ode23")# ode23 5001 steps, intended for non-stiff problems!
  ode45 <- read_rds("out/2023-04-01_out-ode45.rds") |> make_combinable("ode45") # ode45 5001 steps
  bdf <- read_rds("out/2023-04-01_out-bdf.rds") |> make_combinable("bdf")     # bdf stiff 2523
  daspk <- read_rds("out/2023-04-02_out-daspk.rds") |> make_combinable("daspk")     # stiff 2523
  lsoda <- read_rds("out/2023-04-02_out-lsoda.rds") |> make_combinable("lsoda")     # stiff 2523
#+end_src

#+RESULTS:

#+begin_src R
  allout <- bind_rows(rk4, ode23, ode45, bdf, daspk, lsoda)
#+end_src

#+RESULTS:
: Error in list2(...) : object 'ode23' not found

** plot the output
and contrast to the C-results
this depends on snv_sout from [[file:~/SurfDrive/Postdoc1/prj/2023-03-23_snvec-R/README.org::*inspect the c output][inspect the c output]]

*** read in the raw spin vector s from the C-routine
the raw spin vector s, added as something that we write to file myself (not sure if correct!)
#+begin_src R
  snv_sout <- read_table("snvec-3.7.5/s-out.dat",
                        col_names = c("time", "sx", "sy", "sz", "x")) |>
    # this is because there's some whitespace there?
    # note that t is in tmv / KY2D = in kyr
    select(-x)
#+end_src

#+RESULTS:
:
: [36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
: cols(
:   time = [32mcol_double()[39m,
:   sx = [32mcol_double()[39m,
:   sy = [32mcol_double()[39m,
:   sz = [32mcol_double()[39m,
:   x = [33mcol_logical()[39m
: )


*** plot the spin vector s together with the C-routine for easy inspection
#+begin_src R :results output graphics file :output graphics file :file 2023-03-29_output.png :width 700
  comb <- snv_sout |>
    mutate(code = "C") |>
    bind_rows(
      out |>
      as_tibble() |>
      select(time, sx, sy, sz) |>
      mutate(time = time / KY2D) |>
      mutate(code = "R") |>
      mutate(across(time:sz, as.numeric)))


  pl_s <- comb |>
    pivot_longer(cols = sx:sz) |>
    ggplot(aes(x = time, y = value, colour = name, linetype = code)) +
    geom_line() +
    geom_point() +
    annotate("rug",
             y = c(0.404360548210294,
                   -0.053622586775944,
                   0.913026378223150),
             sides = "l",
             colour = scales::hue_pal()(3),
             length = grid::unit(1, "cm"))
  pl_s
#+end_src

#+RESULTS:
[[file:2023-03-29_output.png]]

**** SOME make a plot of the difference between the two
:LOGBOOK:
- State "SOME"       from              [2023-04-04 Tue 11:15]
:END:
but they're not on the same timesteps so that would be annoying...

*** make the figure interactive in the browser
#+begin_src R
  plotly::toWebGL(plotly::ggplotly(pl_s, dynamicTicks = TRUE))
#+end_src

#+RESULTS:
: There were 15 warnings (use warnings() to see them)

** COMMENT plot the different methods
:PROPERTIES:
:CREATED:  [2023-04-02 Sun 11:24]
:END:
the different methods (other then timestep) result in identical results!!

#+begin_src R :results output graphics file :output graphics file :file 2023-04-02_all-output.png :width 700 :eval never
  allout |>
    pivot_longer(cols = sx:sz) |>
    ggplot(aes(x = time, y = value, colour = name, linetype = method)) +
    geom_line() +
    geom_point() +
    annotate("rug",
             y = c(0.404360548210294,
                   -0.053622586775944,
                   0.913026378223150),
             sides = "r",
             colour = c("red", "green", "blue"),
             length = grid::unit(1, "cm")) +
   coord_cartesian(xlim = c(-20*KY2D, 0))
#+end_src

#+RESULTS:
[[file:2023-04-02_all-output.png]]

** print the final values for s
:LOGBOOK:
- State "SOME"       from              [2023-03-29 Wed 12:03]
:END:
do we mean the value at time == 0? -> no! It's going back from 0 to -time
#+begin_src R
  fin <- out[nrow(out), ]
  ## fin <- out[1, ]
  u <- as.vector(c(fin[2], fin[3], fin[4]))
  message(glue::glue("Final values s[1][2][3]; s-error = |s|-1:\n {paste(fin[2], fin[3], fin[4])}\n {sqrt(abs(pracma::dot(u, u)))-1}"))
#+end_src

#+RESULTS:
: Final values s[1][2][3]; s-error = |s|-1:
: 0.404197400723194 -0.0537088738295803 0.91303387030935
: -5.44863786333671e-05

This is what it should look like compared to the C-routine:
#+begin_example
@ Final values s[1][2][3]; s-error = |s|-1:
 0.404360548210294 -0.053622586775944  0.913026378223150
 1.046379e-09
#+end_example

** unwrap function
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
I used some help by chatgpt for the next few functions to explain the c-code

[[file:snvec-3.7.5/snvec-3.7.5.c::=== unwrap()][unwrap()]]
#+begin_src R
  #' unwrap angle.
  #'
  #' Unwrap angle. Maps jumps greater than pi to their 2pi complement.
  #'
  #' @param y Input vector in degrees.
  #' @return Unwrapped vector in degrees.
  unwrap <- function(y) {
    # let's stop being smart and just build it like Richard did in C
    cv <- rep(0, length(y)) # to make them the same length

    # vectorized ## dy <- diff(y) / R2D
    for(i in 2:length(y)){
      dy <- (y[i] - y[i-1])/R2D # vectorized
      if(dy > pi){
        c <- c - 2.*pi
      } else
        if(dy < -pi){
          c <- c + 2.*pi
        }
      cv[i] <- c
    }
    # ok I'll vectorize this one...
    yu <- y + cv*R2D
  }
#+end_src

#+RESULTS:

** unwrap
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:03]
:END:
unwrap lph, lan
*** calculate the unwraps for lph and lan
#+begin_src R
  dat <- dat |>
    mutate(lphu = unwrap(lph),
           lanu = unwrap(lan))
#+end_src

#+RESULTS:

lphu <- unwrap(lph, ls)

*** inspect the unwrap
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 13:18]
:END:

#+begin_src R :results output graphics file :file test-unwrap.png
  dat |>
    filter(age < 500) |>
    ggplot(aes(x = age, y = lph)) +
    scale_x_reverse() +
    geom_line() +
    geom_line(aes(y = lphu), col = "red")
#+end_src

#+RESULTS:
[[file:test-unwrap.png]]

*** inspect C unwrap output
#+begin_src R :results output graphics file :file test-unwrap-vs-C.png
  cunwrap <- read_table("snvec-3.7.5/out-wrap.dat",
                        col_names = c("age", "lphu", "lanu", "x")) |>
    select(-x)

  dat |>
    filter(age > -1e3) |>
    ggplot(aes(x = -age, y = lph)) +
    geom_line() +
    geom_line(aes(y = lphu), colour = "blue") +
    xlim(c(-1e3, 0)) +
    ylim(c(-2e3, 2e2)) +
    geom_line(aes(x = age, y = lphu),
              data = cunwrap |>
                filter(age > -1e3),
              col = "red")
#+end_src

#+RESULTS:
[[file:test-unwrap-vs-C.png]]

** interpolate the orbital solution
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:04]
:END:
back onto output timescale
#+begin_src R
  out <- out |>
    as_tibble() |>
    mutate(
      m = min(round(abs(time / dts)+1), nrow(dat)),
      dx = time - dat$t[m],
      nnx = qinterp(dat$nnx, dts, dx, m),
      nny = qinterp(dat$nny, dts, dx, m),
      nnz = qinterp(dat$nnz, dts, dx, m),
      eei = qinterp(dat$ee, dts, dx, m),
      inci = qinterp(dat$inc, dts, dx, m),
      lphi = qinterp(dat$lphu, dts, dx, m),
      lani = qinterp(dat$lanu, dts, dx, m)
    )
#+end_src

#+RESULTS:

** NEXT calculate obliquity
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:12]
:END:
#+begin_src R
  out <- out |>
    # for each row, extract sx, sy, sz, and nnx, nny, nnz as vectors
    rowwise() |>
    mutate(u = list(as.vector(c(sx, sy, sz))),
           nv = list(as.vector(c(nnx, nny, nnz)))) |>
    # and calculate the dotproduct, richard's vvdot
    mutate(tmp = pracma::dot(u, nv),
           epl = acos(tmp))
#+end_src

#+RESULTS:
: Warning message:
: [1m[22mThere were 944 warnings in `mutate()`.
: The first warning was:
: [1m[22m[36mâ„¹[39m In argument: `epl = acos(tmp)`.
: [36mâ„¹[39m In row 281.
: Caused by warning in `acos()`:
: [33m![39m NaNs produced
: [1m[22m[36mâ„¹[39m Run `dplyr::last_dplyr_warnings()` to see the 943 remaining warnings.

** NEXT calculate precession and climatic precession
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:14]
:END:
#+begin_src R
  out <- out |>
    mutate(
      # coords: fixed HCI => moving orbit plane
      up = list(euler(u, inci / R2D, lani / R2D, 0)),
      # coords: relative to phi(t=0)=0 at J2000
      up = list(euler(up, 0, -(lani + OMT) / R2D - pi / 2, 0) |> as.vector())) |>
      # get 2nd and 1st column of up
      ## phi = list(map(up, ~ atan2(.x[2], .x[1]))),
      ## cp = eei * sin((lphi + OMT) / R2D - phi)
    ## )
#+end_src

#+RESULTS:

*** NEXT fix phi
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 13:06]
:END:

** message user about final values
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:18]
:END:
#+begin_src R
  message(glue::glue("Final values obliquity, precession (rad): \n {paste(out[nrow(out), 'epl'], out[nrow(out), 'phi'])}"))
#+end_src

#+RESULTS:
: Final values obliquity, precession (rad):
: 1.5167803858454 5

** write output files
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:22]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-29 Wed 12:23]
:END:
for now write the rds output
#+begin_src R :eval query
  write_rds(out, "out/2023-04-04_out.rds")
#+end_src

#+RESULTS:

** plot final values
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 14:14]
:END:
*** epl
#+begin_src R :results output graphics file :file final_epl.png :width 700
  out |>
   mutate(age = -time/KY2D) |>
   ggplot(aes(x = age, y = epl)) +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:final_epl.png]]

*** phi
#+begin_src R :results output graphics file :file final_phi.png :width 700
  out |>
   mutate(age = -time / KY2D) |>
   ggplot(aes(x = age, y = phi)) +
   geom_hline(yintercept = c(-pi, pi), col = "red") +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:final_phi.png]]

* snvec.c
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c]]

*** define global variables
once we turn this into a package, best to define them using a function
#+begin_src R
  ## def_globals <- function()
#+end_src

for now do it the simple way

#+RESULTS:

*** quick interpolation
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== qinterp()][qinterp()]]
not sure if needed, could just use R's interp?
#+begin_src R
  qinterp <- function(y, ds, dx, m) {
    yi <- y[m]
    dy <- 0.
    dsa <- abs(ds)
    dxa <- abs(x)
    mm <- 1L

    if (dxa > DBL_EPSILON) {
      mm <- m -
    }
  }
#+end_src

linear interpolation using approx
#+begin_src R
  x = c(41, 45, seq(48, 50, length.out = 8))
  y = rnorm(length(x), 0, 1)
  z = approx(x = x, y = y, xout = 41:50)$y

  plot(x, y, type = "o")
  points(41:50, z, col = "red", pch = 3)
#+end_src

#+RESULTS:
: [1m[33mError[39m in `tibble()`:[22m
: [1m[22m[33m![39m Tibble columns must have compatible sizes.
: [36mâ€¢[39m Size 10: Existing data.
: [36mâ€¢[39m Size 50: Column `z`.
: [36mâ„¹[39m Only values of size one are recycled.
: [90mRun `rlang::last_trace()` to see where the error occurred.[39m

#+begin_src R
    qinterp <- function(x) {
    approx(x = x, y = y, xout = )
  }
#+end_src
*** unwrap
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
I used some help by chatgpt for the next few functions to explain the c-code
[[file:snvec-3.7.5/snvec-3.7.5.c::=== unwrap()][unwrap()]]
*** euler
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:39]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== euler()][euler()]]

*** fvei
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fvei()][fvei()]]
calculates global h,k,p,q etc. from ecc,inc etc.

#+begin_src R
  #' fvei
  #'
  #' calculates global h,k,p,q etc. from ecc,inc etc.
  fvei <- function(ee, inc, lph, lan, ls) {
    hh <- ee * sin(lph / R2D)
    kk <- ee * cos(lph / R2D)
    pp <- 2. * sin(0.5 * inc / R2D) * sin(lan / R2D)
    qq <- 2. * sin(0.5 * inc / R2D) * cos(lan / R2D)
    cc <- cos(inc / R2D)
    dd <- cos(inc / R2D/2.)
    ## /* nn <- nvec(t): normal to orbit */
    nn[1] <-  sin(inc / R2D) * sin(lan / R2D)
    nn[2] <- -sin(inc / R2D) * cos(lan / R2D)
    nn[3] <-  cos(inc / R2D)
  }
#+end_src

for now put these values in a simple script below
*** finargs
[[file:snvec-3.7.5/snvec-3.7.5.c::=== finargs()][finargs()]]
 parse input arguments. arg list:
 [1] tend
 [2] Ed
 [3] Td
 [4] dir  OrbitSoln
 [5] file OrbitSoln

*** fedtd
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fedtd() ][fedtd()]]
calculates global vars ndn,wdw,k0d from Td,Ed

#+begin_src R
  # as a function of ed, td
  k0d <- ((3./2.)*GM*ED0*ed/(OM*AU3))*D2S # 1/s => 1/d
  k0b0 <- k0d*(1.+BET0)
  ndn <- -4.6e-18*D2S*td # 1/s => 1/d
  wdw <- 51.*ndn*NW0 # Lambeck80, see PTman
  tdg <- td # global Td
#+end_src

#+RESULTS:
: Error: object 'ed' not found
: Error: object 'k0d' not found
: Error: object 'td' not found
: Error: object 'ndn' not found
: Error: object 'td' not found

*** finits
[[file:snvec-3.7.5/snvec-3.7.5.c::=== finits() ][finits()]]
init spin vector, transform to HCI
s,n in HCI. s',n' in ECLIPJ2000

calculates np
s0p
via euler transform

*** derivs
[[file:snvec-3.7.5/snvec-3.7.5.c::=== derivs()][derivs()]]

derivatives. RHS of DEQs for spin vector s = y

uses quinterp
#+begin_src R
  derivs <- function(t, y, yp) {
    kb <- ...
    ...
  }
#+end_src

yp[1]
yp[2]
yp[3] are the differential equations

qq pp = g-modes and s-modes, direct
cp derivs of h and k,
h and k from g-modes, calculate from ecc and long perihelion

these are prepped in fvei
*** driver
this is the one we want to study that does all the steps!

[[file:snvec-3.7.5/snvec-3.7.5.c::=== driver()][driver()]]
driver routine solving DEQs for spin vector s = y.

this calls =odeint=

odeint(y0,NEQ,t0,tfin,EPSLVR,h1,hmin,&nok,&nbad,derivs,stiff);

where y0 = a vector of size 3 (simple matrix)
NEQ = 3
t0 = 0.0
tfin = tfink * KY2D # days negative
  tfink =  tend = TEND = -1e3 (see finargs)
EPSLVR = 1e-7 global solver control
h1 = 0.1*dxsav
  dxsav = (tfin - t0)/kmax
  kmax = floor(1000.*2.656*sckx)
  sckx = fabs(tfink/1e3)
hmin = 0.0
&nok = ??
&nbad = ??
derivs = function(t, *y, *yp)
stiff = ??

*** odeint
[[file:snvec-3.7.5/fun/solver.c]]
Runge-Kutta driver. calls derivs and SOLVER.
Runge-Kutta driver with adaptive stepsize control. Integrate starting
values ystart[1..nvar] from x1 to x2 with accuracy eps, storing
intermediate results in global variables. h1 should be set as a
guessed first stepsize, hmin as the minimum allowed stepsize (can be
zero). On output nok and nbad are the number of good and bad (but retried
and fixed) steps taken, and ystart is replaced by values at the end of
the integration interval. derivs is the user-supplied routine for
calculating the right-hand side derivative, while SOLVER is the name
of the stepper routine to be used.

*** write outputs
*** [#A] inspect the c output
**** read in the raw spin vector s
the raw spin vector s, added as something that we write to file myself (not sure if correct!)
#+begin_src R
  snv_sout <- read_table("snvec-3.7.5/s-out.dat",
                        col_names = c("time", "sx", "sy", "sz", "x")) |>
    # this is because there's some whitespace there?
    # note that t is in tmv / KY2D = in kyr
    select(-x)
#+end_src

#+RESULTS:
:
: [36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
: cols(
:   time = [32mcol_double()[39m,
:   sx = [32mcol_double()[39m,
:   sy = [32mcol_double()[39m,
:   sz = [32mcol_double()[39m,
:   x = [33mcol_logical()[39m
: )

**** plot the raw spin vector s
#+begin_src R :results output graphics file :file c-output_s.png :width 700
  pl_refs <- snv_sout |>
    pivot_longer(cols = sx:sz) |>
    ggplot(aes(time, value, col = name)) +
    ## facet_grid(rows = vars(name), scales = "free_y") +
    ## scale_x_reverse() +
    geom_line() +
    ## geom_point() +
    # fix the xlim so that when we add other data it doesn't rescale
    xlim(c(-1e3, 0))
  pl_refs
#+end_src

#+RESULTS:
[[file:c-output_s.png]]

**** read the final eccentricity, phi, precession
#+begin_src R
  snv_out <- read_table("snvec-3.7.5/out.dat",
                        col_names = c("t", "epl", "phi", "cp", "x")) |>
    # this is because there's some whitespace there?
    # note that t is in tmv / KY2D = in kyr
    select(-x)

#+end_src

#+RESULTS:
:
: [36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
: cols(
:   t = [32mcol_double()[39m,
:   epl = [32mcol_double()[39m,
:   phi = [32mcol_double()[39m,
:   cp = [32mcol_double()[39m,
:   x = [33mcol_logical()[39m
: )

**** plot the final eccentricity, phi, precession
#+begin_src R :results output graphics file :file c-output_ee.png :width 700
  pl_ref <- snv_out |>
    pivot_longer(cols = epl:cp) |>
    ggplot(aes(t, value)) +
    facet_grid(rows = vars(name), scales = "free_y") +
    ## scale_x_reverse() +
    geom_line() +
    geom_point() +
    # fix the xlim so that when we add other data it doesn't rescale
    xlim(c(-1e3, 0))
  pl_ref
#+end_src

#+RESULTS:
[[file:c-output_ee.png]]

**** plot a histogram of the timesteps in the C-output
#+begin_src R :results output graphics file :file c-output_dt.png :width 700
  snv_out |>
    mutate(dt = t - lag(t)) |>
    ggplot(aes(dt)) +
    geom_histogram(binwidth = 0.001)
#+end_src

#+RESULTS:
[[file:c-output_dt.png]]

*** debug specific functions
[[file:snvec-3.7.5/snvec-3.7.5.c::Ilja's debugging scheme][Ilja's debugging scheme]]
* inspect deSolve package
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 12:02]
:END:
https://cran.r-project.org/package=deSolve
the implicit Runge-Kutta method RADAU (Hairer and Wanner 2010). The package contains also a de novo implementation of several Runge-Kutta methods (Butcher 1987; Press et al. 1992; Hairer, Norsett, and Wanner 2009).

** DONE calculate precession and obliquity/tilt based on values for \(E_{d}\) and \(T_{d}\)
CLOSED: [2023-03-29 Wed 14:09]
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
** SOME make the output easily accessible as well
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 13:59]
:END:
** DONE what are the parameters that are needed for the differential equations?
CLOSED: [2023-03-29 Wed 12:01]
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 13:54]
:END:
** reproduce their C-implementation that uses an input
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 11:30]
:END:
[[file:~/Downloads/compiledCode.pdf::25]]

#+begin_src R
  library(deSolve)
  SPCmod <- function(t, x, parms, input) {
    with(as.list(c(parms, x)), {
      import <- input(t)
      dS <- import - b * S * P + g * C # subtrate
      dP <- c * S * P - d * C * P      # producer
      dC <- e * P * C - f * C          # consumer
      res <- c(dS, dP, dC)
      list(res, signal = import)
    })
  }

  parms <- c(b = .1, c = .1, d = .1, e = .1, f = .1, g = 0)

  times <- seq(0, 100, .1)
  signal <- as.data.frame(list(times = times,
                               import = rep(0, length(times))))
  signal$import <- ifelse((trunc(signal$times) %% 2 == 0), 0, 1)
  sigimp <- approxfun(signal$times, signal$import, rule = 2)

  xstart <- c(S = 1, P = 1, C = 1)
  print(system.time(
    out <- ode(y = xstart, times = times,
               func = SPCmod, parms, input = sigimp)
  ))
  plot(out)
#+end_src
* compare c and R output
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 10:24]
:END:
#+begin_src R :results output graphics file :file compare_c-R.png :width 700
  pl_ref +
    geom_line(aes(x = time / KY2D),
              data = out |>
                select(time, epl# ## phi, cp
                       ) |>
                pivot_longer(cols = c(epl, ## phi, cp
                                      )),
              col = "red")
#+end_src

#+RESULTS:
[[file:compare_c-R.png]]
* tasks
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:27]
:END:
** DONE play around with the different ODE solver algorithms to figure out which one is fastest
CLOSED: [2023-04-04 Tue 09:28]
** DONE make the R routine visually return the same spin vector as the C routine
CLOSED: [2023-04-04 Tue 09:27]
** NEXT make the R routine return machine precision close to identical results to the C routine
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:27]
:END:
- hmm it's not the fact that in the C routine he doesn't interpolate the results for hh and kk
- check for a long run if the error stays 1e-3 or if it accumulates -> it accumulates, see figs:
   [[file:2023-04-04_compare-c-to-R_56-54Ma.png]]
   [[file:2023-04-04_compare-c-to-R_81-78Ma.png]]
   [[file:2023-04-04_compare-c-to-R_100-97Ma.png]]
- compare C-code to this with times
** NEXT make the R routine return the same values for precession and obliquity
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:29]
:END:
** NEXT make a function out of snvec so it's easy to vary Td and Ed
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:28]
:END:
** NEXT calculate for grids of Td and Ed
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:29]
:END:
** NEXT visualize results: a heat map?
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:29]
:END:
** SOME make the La2011 solution obl + precession available?
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 10:35]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-04-04 Tue 10:36]
:END:
but NOT the 2004 solutions! divergence times at ~40 Ma with 2011 or ZB18a
** SOME check out the Wu paper / acycle
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 10:37]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-04-04 Tue 10:39]
:END:
they apply the Laskar fortran routine from 92/93 to calculate precession/obliquity for the La2011 but that's in the ecliptic reference plane rather than the intertial reference frame.
