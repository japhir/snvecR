#+TITLE: snvec-R
#+AUTHOR: Ilja J. Kocken
#+EMAIL: ikocken@hawaii.edu
written by Ilja J. Kocken [[https://orcid.org/0000-0003-2196-8718][orcid:0000-0003-2196-8718]]

#+PROPERTY: header-args:R  :session *R:snvec-R* :exports both :results output :eval no-export

* snvec-R
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
This project aims to make the =snvec= C-code more readily available to R-users.

snvec: Pre-computed Precession-Tilt solutions and C code.

** citation
#+begin_quote
When using snvec, cite as:

A deep-time dating tool for paleo-applications utilizing obliquity
and precession cycles: The role of dynamical ellipticity and tidal
dissipation, Richard E. Zeebe and Lucas J. Lourens, Paleoceanography
and Paleoclimatology, 2022.

Richard E. Zeebe
School of Ocean and Earth
Science and Technology
University of Hawaii at Manoa
1000 Pope Road, MSB 504
Honolulu, HI 96822, USA
email: zeebe@soest.hawaii.edu
#+end_quote

** load libraries
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 09:14]
:END:
#+begin_src R
  library(tidyverse)
  # make sure you have `glue` for the info messages
#+end_src

#+RESULTS:
#+begin_example
â”€â”€ [1mAttaching core tidyverse packages[22m â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€
[32mâœ”[39m [34mdplyr    [39m 1.1.1     [32mâœ”[39m [34mreadr    [39m 2.1.4
[32mâœ”[39m [34mforcats  [39m 1.0.0     [32mâœ”[39m [34mstringr  [39m 1.5.0
[32mâœ”[39m [34mggplot2  [39m 3.4.1     [32mâœ”[39m [34mtibble   [39m 3.2.1
[32mâœ”[39m [34mlubridate[39m 1.9.2     [32mâœ”[39m [34mtidyr    [39m 1.3.0
[32mâœ”[39m [34mpurrr    [39m 1.0.1
â”€â”€ [1mConflicts[22m â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
[31mâœ–[39m [34mdplyr[39m::[32mfilter()[39m masks [34mstats[39m::filter()
[31mâœ–[39m [34mdplyr[39m::[32mlag()[39m    masks [34mstats[39m::lag()
[36mâ„¹[39m Use the conflicted package ([3m[34m<http://conflicted.r-lib.org/>[39m[23m) to force all conflicts to become errors
#+end_example

** set the version
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:32]
:END:
#+begin_src R
 VER <- "snvec.r VERSION: 3.7.5 03/2023"
#+end_src

#+RESULTS:

** global variables
#+begin_src R
  AU <- 1.49597870700e11 # m
  GM <- 1.32712440041e20 # m3/s2
  OM <- 7.292115e-5      # 1/s EarthRot
  R0 <- 3.8440e8         # m Moon R0
  GK <- 0.9925194        # Kinoshita75,77
  ED0 <- 0.0032738134    # DynEll (C-A)/C
  FGP <- 0.99961908
  AU3 <- AU * AU * AU
  R03 <- R0 * R0 * R0
  # no need to define pi in R
  R2D <- 180. / pi       # radians to deg

  D2S <- 3600. * 24.
  Y2D <- 365.25
  KY2D <- 1.e3 * Y2D

  # set default Ed, Td
  ED <- 1.0000         # set factor 1.0
  TD <- 0.0000         # set factor 0.0

  # mass ratios
  MSEL <- 328900.5596      # MS/(ME+ML)
  MEL <- 81.300568         # ME/ML
  MLS <- 1. / (MSEL * (1 + MEL)) # ML/MS
  # K0, beta0 for torques
  K0 <- (3. / 2.) * GM * ED0 * ED / (OM * AU3)
  K0D <- K0 * D2S          # 1/s => 1/d */
  BET0 <- GK * MLS * AU3 / R03
  K0B0 <- K0D * (1. + BET0)
  # Moon mean motion
  N0 <- sqrt(GM / MSEL / R03)
  NW0 <- (N0 / OM) # ratio (n/om)_0
  # Tidal dissipation Quinn91 Eqs. (3, 11)
  # NDN = (dndt/n)_0, WDW = (domdt/om)_0
  NDN <- (-4.6e-18 * D2S * TD) # 1/s => 1/d
  WDW <- (51. * NDN * NW0)     # Lambeck80
  # tidal effect on obliquity
  UEPSDOT <- -4.17e-19

  # SunRot Angles (Transform to HCI)
  OMT <- 75.5940
  INCT <- 7.155
  EP0 <- 23.439291111111110 # Obliquity t0
#+end_src

#+RESULTS:

** read in the orbital solution ZB18a
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
[[file:snvec-3.7.5/ems-plan3.dat]]

the top of the file has some lines specifying which columns were used
0  7  8  9  12 10 11 15

#+begin_src R :results value :colnames yes
  library(readr)

  dat <- read_table("snvec-3.7.5/ems-plan3.dat",
                    comment = "#",
                    skip = 3,
                    col_names = c(
                      "time",
                      ## "x1", "x2", "x3",
                      ## "v1", "v2", "v3",
                      "semimajor_axis",
                      "eccentricity",
                      "inclination",
                      "long_periapse",
                      ## "time_periapse",
                      "long_ascend_node",
                      "arg_periapse",
                      ## "peri_distance",
                      "mean_anomaly"#, "true_anomaly",
                      ## "mean_longitude", "true_longitude",
                      ## "mean_latitude", "true_latitude",
                      ## "mass",
                      ## "enc_radius",
                      ## "capt_radius",
                      ## "id_tag",
                      ## "jac_index"
                    ))

  head(dat) |> round(2)
#+end_src

#+RESULTS:
|    time | semimajor_axis | eccentricity | inclination | long_periapse | long_ascend_node | arg_periapse | mean_anomaly |
|---------+----------------+--------------+-------------+---------------+------------------+--------------+--------------|
|       0 |              1 |         0.02 |        7.15 |         27.32 |              180 |      -152.68 |        -2.45 |
| -146100 |              1 |         0.02 |        7.15 |         26.12 |          -179.59 |      -154.29 |         1.27 |
| -292200 |              1 |         0.02 |        7.14 |         24.69 |          -179.17 |      -156.14 |         5.22 |
| -438300 |              1 |         0.02 |        7.12 |         23.67 |          -178.75 |      -157.58 |         8.75 |
| -584400 |              1 |         0.02 |        7.11 |         22.12 |          -178.34 |      -159.54 |         12.8 |
| -730500 |              1 |         0.02 |         7.1 |            21 |          -177.92 |      -161.08 |        16.45 |

** rename some of the names in dat
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:14]
:END:
#+begin_src R
  dat <- dat |>
    tidylog::rename(
      ee = eccentricity,
      inc = inclination,
      lph = long_periapse,
      lan = long_ascend_node)
#+end_src

#+RESULTS:
: rename: renamed 4 variables (ee, inc, lph, lan)

** input parameters of the final function/program
#+begin_src R
  ed <- 1
  td <- 0
  tend <- -1e3
#+end_src

#+RESULTS:

** check inputs
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 11:56]
:END:
#+begin_src R
  if (tend >= 0) {
    stop(glue::glue("`tend` must be < 0, but tend = {tend}"))
  }
  if (tend < min(dat$time / KY2D)) {
    stop(glue::glue("`tend` must be < the orbital solution {min(dat$time)/KY2D}, but tend = {tend}."))
  }
#+end_src

#+RESULTS:

** message user about inputs
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:31]
:END:
#+begin_src R
  message(glue::glue("This is {VER}"))
  message("Richard E. Zeebe")
  message("Ilja J. Kocken")
  message("Integration parameters:")
  message(glue::glue(" tend = {tend} kyr"))
  message(glue::glue(" Ed = {ed}"))
  message(glue::glue(" Td = {td}"))
#+end_src

#+RESULTS:
: This is snvec.r VERSION: 3.7.5 03/2023
: Richard E. Zeebe
: Ilja J. Kocken
: Integration parameters:
:  tend = -1000 kyr
:  Ed = 1
:  Td = 0

** calculate helper parameters
see fvei
helper parameters as new columns of dat
#+begin_src R
  dat <- dat |>
    mutate(age = - time / KY2D, .after = time) |>
    rowwise() |>
    mutate(hh = ee * sin(lph / R2D),
           kk = ee * cos(lph / R2D),
           pp = 2 * sin(0.5 * inc / R2D) * sin(lan / R2D),
           qq = 2 * sin(0.5 * inc / R2D) * cos(lan / R2D),
           cc = cos(inc / R2D),
           dd = cos(inc / R2D / 2),
           ## /* nn <- nvec(t): normal to orbit */
           nnx = sin(inc / R2D) * sin(lan / R2D),
           nny = -sin(inc / R2D) * cos(lan / R2D),
           nnz = cos(inc / R2D))
  # SOME: do it as a list of vectors in stead?
           ## nn = list(c(sin(inc / R2D) * sin(lan / R2D),
           ##             -sin(inc / R2D) * cos(lan / R2D),
           ##             cos(inc / R2D))))
#+end_src

#+RESULTS:

*** SOME I've just changed nnx nny nnz to a single list of vectors nn
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 12:26]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-03-30 Thu 12:34]
:END:

** plot orbital solution input
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 14:20]
:END:
*** ee
#+begin_src R :results output graphics file :file input_ee.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = ee)) +
   labs(x = "Age (Ma)", y = "Eccentricity") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:input_ee.png]]

*** inc
#+begin_src R :results output graphics file :file input_inc.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = inc)) +
   labs(x = "Age (Ma)", y = "Inclination") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:input_inc.png]]

*** lph
#+begin_src R :results output graphics file :file input_lph.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = lph)) +
   labs(x = "Age (Ma)", y = "Long Periapse") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:input_lph.png]]

*** lan
#+begin_src R :results output graphics file :file input_lan.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = lan)) +
   labs(x = "Age (Ma)", y = "Long Ascending Node") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:input_lan.png]]

*** h, k, p, q
#+begin_src R :results output graphics file :file input_hkpq.png :width 700 :eval never
  dat |>
    select(age, hh, kk, pp, qq, cc, dd) |>
    pivot_longer(hh:dd) |>
    ggplot(aes(x = age / 1e3, y = value)) +
    labs(x = "Age (Ma)") +
    scale_x_reverse() +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line()
#+end_src

#+RESULTS:
[[file:input_hkpq.png]]

** calculate global vars ndn, wdw, k0d from Td and Ed
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:40]
:END:
see fedtd
#+begin_src R
  # as a function of ed, td
  k0d <- ((3 / 2) * GM * ED0 * ed / (OM * AU3)) * D2S # 1/s => 1/d
  k0b0 <- k0d * (1 + BET0)
  ndn <- -4.6e-18 * D2S * td # 1/s => 1/d
  wdw <- 51 * ndn * NW0 # Lambeck80, see PTman
  tdg <- td # global Td
#+end_src

#+RESULTS:

** NEXT the euler transformation
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 15:14]
:END:

#+begin_src R
  #' Euler transformation.
  #'
  #' s* = A * s, where spin vector s is in invariable plane and s* in instant
  #' orbit plane. inv = 1 gives inverse transformation (A^-1 = A' =
  #' transpose(A)).
  #' @param s The vector to be transformed.
  #' @param inc  The inclination.
  #' @param lan  The Long Ascending Node
  #' @param inv  Invert the output.
  euler <- function(s, inc, lan, inv = FALSE) {
    a <- matrix(c(cos(lan), sin(lan), 0,
                  -cos(inc) * sin(lan), cos(inc) * cos(lan), sin(inc),
                  sin(inc) * sin(lan), -sin(inc) * cos(lan), cos(inc)),
                nrow = 3)
    if (inv) a <- t(a)
    a %*% s
  }
#+end_src

#+RESULTS:

** initial values for the spin vector s
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:04]
:END:
finits

use finits to get initial conditions in transformed ECLIPJ2000

#+begin_src R
  omt <- OMT / R2D
  inct <- INCT / R2D
  ep0 <- EP0 / R2D
  cs <- cos(ep0)

  # first row of nn -> needs to be a vector
  # orbit normal at t=0
  ninit <- dat |>
    filter(time == 0) |>
    select(nnx, nny, nnz) |>
    as.matrix() |>
    as.vector()

  # transform n => n'
  np <- euler(ninit, inct, omt, TRUE)

  # solve quadratic equation for s0'y
  a <- np[2] * np[2] + np[3]*np[3]
  b <- -2 * cs * np[2]
  c <- cs*cs - np[3] * np[3]

  s0p <- c(NA, NA, NA)
  s0p[2] <- (-b + sqrt(b*b-4*a*c))/(2*a)
  s0p[3] <- sqrt(1-s0p[2]*s0p[2])
  s0p[1] <- 0
  as.matrix(s0p)

  # transform s0' to s0
  s0 <- euler(s0p, inct, omt, 0)
#+end_src

#+RESULTS:
:           [,1]
: [1,] 0.0000000
: [2,] 0.5208739
: [3,] 0.8536336

** set the deSolve state
#+begin_src R
  state <- c(sx = s0[1],
             sy = s0[2],
             sz = s0[3])
#+end_src

#+RESULTS:

** define deSolve parameters
#+begin_src R
  parameters <- c(
    ed = ed,
    td = td,
    k0d = k0d,
    wdw = wdw,
    ndn = ndn)
#+end_src

#+RESULTS:

** our inputs change as a function of time, so we need a function to describe them
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 09:06]
:END:
richard does this with qinterp
http://desolve.r-forge.r-project.org/ has an article on time-varying inputs
we use approxfun to generate a function that approximates =col= for timestep t.

#+begin_src R
  qinterp <- function(dat, col = ee) {
    dat |>
     select(time, {{col}}) |>
     approxfun(rule = 2)
  }
#+end_src

#+RESULTS:

**** double-check that the interpolation is working
#+begin_src R :eval never
  input <- dat |>
    select(time, ee) |>
    approxfun(rule = 2)

  # this creates a function that we can call from within the other function
  # e.g.
  input(1.42 * KY2D)
#+end_src

#+RESULTS:
: [1] 0.01670545

> I created the function

#+begin_src R :results output graphics file :file qinterp_test.png
  dat |>
    slice(1:3) |>
    ggplot(aes(x = time, y = lph)) +
    geom_line() +
    geom_point() +
    annotate("point", x = -.45 * KY2D, y = qinterp(dat, lph)(-.45 * KY2D), col = "red")
#+end_src

#+RESULTS:
[[file:qinterp_test.png]]

** the differential equations
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 11:56]
:END:
see [[derivs]]

#+begin_src R
  # derivatives. RHS of DEQs for spin vector s = y
  eqns <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {

      # K0, beta0 changing with Td, Ed
      kb <- k0d * (1 + 1 * wdw * t) * (1 + BET0 * (1 + 2 * ndn * t))

      # set time index of solution
      dts <- diff(dat$time)[1]
      ## t <- dat$time[5] # e.g.
      m <- min(round(abs(t / dts) + 1), nrow(dat))

      # for interpolation we can use t directly
      ## if (qinterp) {
      # we call on global dat for now
      qqi <- qinterp(dat, qq)(t)
      ppi <- qinterp(dat, pp)(t)
      cci <- qinterp(dat, cc)(t)
      ddi <- qinterp(dat, dd)(t)
      ## }

      # 1/(1-e^2)^3/2 term
      ff <- (1 - dat$hh[m] * dat$hh[m] - dat$kk[m] * dat$kk[m])
      # shouldn't I also interpolate hh and kk?
      ff <- 1 / sqrt(ff*ff*ff)
      kb <- k0d * (1 + 1 * wdw * t) * (ff + BET0 * (1 + 2 * ndn * t))

      fac <- FGP * kb * (ddi * (ppi * sx - qqi * sy) + cci * sz)

      dX <-  fac * ( cci * sy + ddi * qqi * sz)
      dY <-  fac * (-cci * sx + ddi * ppi * sz)
      dZ <- -fac * ( qqi * sx + ppi * sy) * ddi

      # EPSDOT
      ## dotab = s[1]*nn[1][m]+s[2]*nn[2][m]+s[3]*nn[3][m];
      ## tmp = tdg*EPSDOT*D2S/sqrt(1.-dotab*dotab);
      ## yp[1] += tmp*(nn[1][m] - dotab*s[1]);
      ## yp[2] += tmp*(nn[2][m] - dotab*s[2]);
      ## yp[3] += tmp*(nn[3][m] - dotab*s[3]);

      list(c(dX, dY, dZ))
    }) # end 'with(as.list( ...
  }
#+end_src

#+RESULTS:

** NEXT timesteps to report
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:08]
:END:

#+begin_src R
  ## EPSLVR <- 1.e-7 # accuracy 1e-7 2.2e-7/8.5e-7 La
  times <- seq(tend * KY2D, 0, by = 1 * KY2D)
#+end_src

#+RESULTS:

** solve the system of ODEs
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:11]
:END:

odeint(y0,NEQ,t0,tfin,EPSLVR,h1,hmin,&nok,&nbad,derivs,stiff);

#+begin_src R :eval query
  library(deSolve)
  print(system.time(
    out <- ode(y = state,
               times = times,
               func = eqns,
               parms = parameters,
               method = "rk4") # ode23 ode45 radau
  ))
#+end_src

#+RESULTS:
:
: Attaching package: â€˜deSolveâ€™
:
: The following object is masked _by_ â€˜.GlobalEnvâ€™:
:
:     euler
:    user  system elapsed
: 968.762   0.073 972.058

#+begin_src R
lubridate::as.duration(968.762)
#+end_src

#+RESULTS:
: [1] "968.762s (~16.15 minutes)"

*** save the output
#+begin_src R
  write_rds(out, "out/2023-03-30_out.rds")
#+end_src
*** read in previous results
#+begin_src R
  out <- read_rds("out/2023-03-29_out.rds")
#+end_src

#+RESULTS:

*** plot the output
clean it up because I cannot deal with base graphics right now

#+begin_src R :results output graphics file :output graphics file :file 2023-03-29_output.png :width 700
  library(tidyverse)

  out |>
   as_tibble() |>
   pivot_longer(cols=c(sx, sy, sz)) |>
   ggplot(aes(x = time, y = value, colour = name)) +
   geom_line()
#+end_src

#+RESULTS:
[[file:2023-03-29_output.png]]

** print the final values for s
:LOGBOOK:
- State "SOME"       from              [2023-03-29 Wed 12:03]
:END:
do we mean the value at time == 0?
#+begin_src R
  fin <- out[nrow(out), ]
  ## fin <- out[1, ]
  u <- as.vector(c(fin[2], fin[3], fin[4]))
  message(glue::glue("Final values s[1][2][3]; s-error = |s|-1:\n {paste(fin[2], fin[3], fin[4])}\n {sqrt(pracma::dot(u, u))-1}"))
#+end_src

#+RESULTS:
: Error in pracma::dot(u, u) :
:   Arguments 'x' and 'y' must be real or complex.

** NEXT unwrap function
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
I used some help by chatgpt for the next few functions to explain the c-code

[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== unwrap()][unwrap()]]
#+begin_src R
  #' unwrap angle.
  #'
  #' unwrap angle. maps jumps greater than pi to their 2pi complement.
  unwrap <- function(y) {
    ## stopifnot(length(y) > 1L)

    dy <- diff(y) / R2D

    cor <- cumsum(ifelse(dy > pi, -2 * pi,
                  ifelse(dy < -pi, 2 * pi, 0)))
    yu <- y[-1] + cor * R2D
    return(c(y[1], yu))
  }
#+end_src

#+RESULTS:

** unwrap
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:03]
:END:
unwrap lph, lan

#+begin_src R
  dat <- dat |>
    mutate(lphu = unwrap(lph),
           lanu = unwrap(lan))
#+end_src

#+RESULTS:

lphu <- unwrap(lph, ls)

*** inspect the unwrap
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 13:18]
:END:

#+begin_src R :results output graphics file :file test-unwrap.png
  dat |>
    filter(age < 500) |>
    ggplot(aes(x = age, y = lph)) +
    scale_x_reverse() +
    geom_line() +
    geom_line(aes(y = lphu), col = "red", lty = 2)
#+end_src

#+RESULTS:
[[file:test-unwrap.png]]

** interpolate the orbital solution
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:04]
:END:
#+begin_src R
  out <- out |>
    as_tibble() |>
    mutate(
      ## m = min(round(abs(time / )))
      ## dx = diff(time),
      nnx = qinterp(dat, nnx)(time),
      nny = qinterp(dat, nny)(time),
      nnz = qinterp(dat, nnz)(time),
      eei = qinterp(dat, ee)(time),
      inci = qinterp(dat, inc)(time),
      lphi = qinterp(dat, lphu)(time),
      lani = qinterp(dat, lanu)(time)
    )
#+end_src

#+RESULTS:
: Error in as_tibble(out) : object 'out' not found

** NEXT calculate obliquity
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:12]
:END:
#+begin_src R
  out <- out |>
    # for each row, extract sx, sy, sz, and nnx, nny, nnz as vectors
    ## rowwise() |>
    mutate(u = list(as.vector(c(sx, sy, sz))),
           nni = list(as.vector(c(nnx, nny, nnz)))) |>
    # and calculate the dotproduct, richard's vvdot
    mutate(tmp = pracma::dot(u, nni),
           epl = acos(tmp))
#+end_src

#+RESULTS:
: Error in mutate(out, u = list(as.vector(c(sx, sy, sz))), nni = list(as.vector(c(nnx,  :
:   object 'out' not found

** NEXT calculate precession and climatic precession
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:14]
:END:
#+begin_src R
  out <- out |>
    mutate(
      # coords: fixed HCI => moving orbit plane
      up = list(euler(u, inci / R2D, lani / R2D, 0)),
      # coords: relative to phi(t=0)=0 at J2000
      up = list(euler(up, 0, -(lani + OMT) / R2D - pi / 2, 0)),
      # get 2nd and 1st column of up
      phi = atan2(up[, 2], up[, 1]),
      phi = phi - ,
      cp = eei * sin((lphi + OMT) / R2D - phi)) |>
    arrange(-time)
#+end_src

#+RESULTS:
: [1m[33mError[39m in `mutate()`:[22m
: [1m[22m[36mâ„¹[39m In argument: `phi = atan2(up[, 2], up[, 1])`.
: [36mâ„¹[39m In row 1.
: [1mCaused by error in `up[, 2]`:[22m
: [33m![39m subscript out of bounds
: [90mRun `rlang::last_trace()` to see where the error occurred.[39m

** message user about final values
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:18]
:END:
#+begin_src R
  message(glue::glue("Final values obliquity, precession (rad): \n {paste(out[nrow(out), 'epl'], out[nrow(out), 'phi'])}"))
#+end_src

#+RESULTS:
: Error in paste(out[nrow(out), "epl"], out[nrow(out), "phi"]) :
:   object 'out' not found

** write output files
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:22]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-29 Wed 12:23]
:END:
for now write the rds output
#+begin_src R :eval query
  write_rds(out, "out/2023-03-29_out.rds")
#+end_src

#+RESULTS:

** plot final values
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 14:14]
:END:
*** epl
#+begin_src R :results output graphics file :file final_epl.png :width 700
  out |>
   mutate(age = -time/KY2D) |>
   ggplot(aes(x = age, y = epl)) +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:final_epl.png]]

*** phi
#+begin_src R :results output graphics file :file final_phi.png :width 700
  out |>
   mutate(age = -time/KY2D) |>
   ggplot(aes(x = age, y = phi)) +
   geom_hline(yintercept = c(-pi, pi), col = "red") +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:final_phi.png]]

* snvec.c
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c]]

*** define global variables
once we turn this into a package, best to define them using a function
#+begin_src R
  ## def_globals <- function()
#+end_src

for now do it the simple way

#+RESULTS:

*** quick interpolation
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== qinterp()][qinterp()]]
not sure if needed, could just use R's interp?
#+begin_src R
  qinterp <- function(y, ds, dx, m) {
    yi <- y[m]
    dy <- 0.
    dsa <- abs(ds)
    dxa <- abs(x)
    mm <- 1L

    if (dxa > DBL_EPSILON) {
      mm <- m -
    }
  }
#+end_src

linear interpolation using approx
#+begin_src R
  x = c(41, 45, seq(48, 50, length.out = 8))
  y = rnorm(length(x), 0, 1)
  z = approx(x = x, y = y, xout = 41:50)$y

  plot(x, y, type = "o")
  points(41:50, z, col = "red", pch = 3)
#+end_src

#+RESULTS:
: [1m[33mError[39m in `tibble()`:[22m
: [1m[22m[33m![39m Tibble columns must have compatible sizes.
: [36mâ€¢[39m Size 10: Existing data.
: [36mâ€¢[39m Size 50: Column `z`.
: [36mâ„¹[39m Only values of size one are recycled.
: [90mRun `rlang::last_trace()` to see where the error occurred.[39m

#+begin_src R
    qinterp <- function(x) {
    approx(x = x, y = y, xout = )
  }
#+end_src
*** NEXT unwrap
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
I used some help by chatgpt for the next few functions to explain the c-code

[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== unwrap()][unwrap()]]
#+begin_src R
  #' unwrap angle.
  #'
  #' unwrap angle. maps jumps greater than pi to their 2pi complement.
  unwrap <- function(y) {
    stopifnot(length(y) > 1L)

    dy <- diff(y) / R2D

    cor <- cumsum(ifelse(dy > pi, -2 * pi,
                  ifelse(dy < -pi, 2 * pi, 0)))
    yu <- y[-1] + cor * R2D
    return(c(y[1], yu))
  }
#+end_src

*** NEXT euler
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:39]
:END:
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== euler()][euler()]]

#+RESULTS:

*** fvei
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== fvei()][fvei()]]
calculates global h,k,p,q etc. from ecc,inc etc.

#+begin_src R
  #' fvei
  #'
  #' calculates global h,k,p,q etc. from ecc,inc etc.
  fvei <- function(ee, inc, lph, lan, ls) {
    hh <- ee * sin(lph / R2D)
    kk <- ee * cos(lph / R2D)
    pp <- 2. * sin(0.5 * inc / R2D) * sin(lan / R2D)
    qq <- 2. * sin(0.5 * inc / R2D) * cos(lan / R2D)
    cc <- cos(inc / R2D)
    dd <- cos(inc / R2D/2.)
    ## /* nn <- nvec(t): normal to orbit */
    nn[1] <-  sin(inc / R2D) * sin(lan / R2D)
    nn[2] <- -sin(inc / R2D) * cos(lan / R2D)
    nn[3] <-  cos(inc / R2D)
  }
#+end_src

for now put these values in a simple script below
*** finargs
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== finargs()][finargs()]]
 parse input arguments. arg list:
 [1] tend
 [2] Ed
 [3] Td
 [4] dir  OrbitSoln
 [5] file OrbitSoln

*** fedtd
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== fedtd() ][fedtd()]]
calculates global vars ndn,wdw,k0d from Td,Ed

#+begin_src R
  # as a function of ed, td
  k0d <- ((3./2.)*GM*ED0*ed/(OM*AU3))*D2S # 1/s => 1/d
  k0b0 <- k0d*(1.+BET0)
  ndn <- -4.6e-18*D2S*td # 1/s => 1/d
  wdw <- 51.*ndn*NW0 # Lambeck80, see PTman
  tdg <- td # global Td
#+end_src

#+RESULTS:
: Error: object 'ed' not found
: Error: object 'k0d' not found
: Error: object 'td' not found
: Error: object 'ndn' not found
: Error: object 'td' not found

*** finits
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== finits() ][finits()]]
init spin vector, transform to HCI
s,n in HCI. s',n' in ECLIPJ2000

calculates np
s0p
via euler transform

*** derivs
[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== derivs()][derivs()]]

derivatives. RHS of DEQs for spin vector s = y

uses quinterp
#+begin_src R
  derivs <- function(t, y, yp) {
    kb <- ...
    ...
  }
#+end_src

yp[1]
yp[2]
yp[3] are the differential equations

qq pp = g-modes and s-modes, direct
cp derivs of h and k,
h and k from g-modes, calculate from ecc and long perihelion

these are prepped in fvei
*** NEXT driver
this is the one we want to study that does all the steps!

[[file:~/Downloads/snvec-3.7.5/snvec-3.7.5.c::=== driver()][driver()]]
driver routine solving DEQs for spin vector s = y.

this calls =odeint=

odeint(y0,NEQ,t0,tfin,EPSLVR,h1,hmin,&nok,&nbad,derivs,stiff);

where y0 = a vector of size 3 (simple matrix)
NEQ = 3
t0 = 0.0
tfin = tfink * KY2D # days negative
  tfink =  tend = TEND = -1e3 (see finargs)
EPSLVR = 1e-7 global solver control
h1 = 0.1*dxsav
  dxsav = (tfin - t0)/kmax
  kmax = floor(1000.*2.656*sckx)
  sckx = fabs(tfink/1e3)
hmin = 0.0
&nok = ??
&nbad = ??
derivs = function(t, *y, *yp)
stiff = ??

*** odeint
[[file:snvec-3.7.5/fun/solver.c]]
Runge-Kutta driver. calls derivs and SOLVER.
Runge-Kutta driver with adaptive stepsize control. Integrate starting
values ystart[1..nvar] from x1 to x2 with accuracy eps, storing
intermediate results in global variables. h1 should be set as a
guessed first stepsize, hmin as the minimum allowed stepsize (can be
zero). On output nok and nbad are the number of good and bad (but retried
and fixed) steps taken, and ystart is replaced by values at the end of
the integration interval. derivs is the user-supplied routine for
calculating the right-hand side derivative, while SOLVER is the name
of the stepper routine to be used.

*** write outputs
*** inspect the c output
#+begin_src R
  snv_out <- read_table("snvec-3.7.5/out.dat", col_names = FALSE)

  snv_out |>
    ggplot(aes(X1, X2)) +
    geom_line() +
    geom_point()
#+end_src

* inspect deSolve package
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 12:02]
:END:
https://cran.r-project.org/package=deSolve
the implicit Runge-Kutta method RADAU (Hairer and Wanner 2010). The package contains also a de novo implementation of several Runge-Kutta methods (Butcher 1987; Press et al. 1992; Hairer, Norsett, and Wanner 2009).

** DONE calculate precession and obliquity/tilt based on values for \(E_{d}\) and \(T_{d}\)
CLOSED: [2023-03-29 Wed 14:09]
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
** SOME make the output easily accessible as well
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 13:59]
:END:
** DONE what are the parameters that are needed for the differential equations?
CLOSED: [2023-03-29 Wed 12:01]
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 13:54]
:END:
** reproduce their C-implementation that uses an input
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 11:30]
:END:
[[file:~/Downloads/compiledCode.pdf::25]]

#+begin_src R
  library(deSolve)
  SPCmod <- function(t, x, parms, input) {
    with(as.list(c(parms, x)), {
      import <- input(t)
      dS <- import - b * S * P + g * C # subtrate
      dP <- c * S * P - d * C * P      # producer
      dC <- e * P * C - f * C          # consumer
      res <- c(dS, dP, dC)
      list(res, signal = import)
    })
  }

  parms <- c(b = .1, c = .1, d = .1, e = .1, f = .1, g = 0)

  times <- seq(0, 100, .1)
  signal <- as.data.frame(list(times = times,
                               import = rep(0, length(times))))
  signal$import <- ifelse((trunc(signal$times) %% 2 == 0), 0, 1)
  sigimp <- approxfun(signal$times, signal$import, rule = 2)

  xstart <- c(S = 1, P = 1, C = 1)
  print(system.time(
    out <- ode(y = xstart, times = times,
               func = SPCmod, parms, input = sigimp)
  ))
  plot(out)
#+end_src

* COMMENT step-by-step
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 15:33]
:END:

** read in the orbital solution

** make them a function of time
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 09:32]
:END:

** specify constants

** specify input values
- tend
- Ed
- Td

** calculate global variables
ndn, wdw, k0d
from Td and Ed

** set up the initial spin vector s
transform them: s, n in HCI, s' and n' in ECLIPJ2000
using the euler function

f(s0, nn, ep0, inct, omt)

** set up the system of differential equations
spin vector s = y
as a function of t, y, and y'
