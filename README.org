#+TITLE: snvec-R
#+AUTHOR: Ilja J. Kocken
#+EMAIL: ikocken@hawaii.edu
written by Ilja J. Kocken [[https://orcid.org/0000-0003-2196-8718][orcid:0000-0003-2196-8718]]

#+PROPERTY: header-args:R  :session *R:snvec-R* :exports both :results output :eval no-export

* snvec-R
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
This project aims to make the =snvec= C-code more readily available to R-users.

snvec: Pre-computed Precession-Tilt solutions and C code.

** setup
*** NEXT include proper way to cite the package
still need to include this in the DESCRIPTION etc.
or there was a package loading thing?

#+begin_quote
When using snvec, cite as:

A deep-time dating tool for paleo-applications utilizing obliquity
and precession cycles: The role of dynamical ellipticity and tidal
dissipation, Richard E. Zeebe and Lucas J. Lourens, Paleoceanography
and Paleoclimatology, 2022.

Richard E. Zeebe
School of Ocean and Earth
Science and Technology
University of Hawaii at Manoa
1000 Pope Road, MSB 504
Honolulu, HI 96822, USA
email: zeebe@soest.hawaii.edu
#+end_quote

*** load libraries
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 09:14]
:END:
#+begin_src R :results none
  library(tidyverse)
  # we use dplyr and ggplot2 mostly
  library(deSolve)
  # we use glue for info messages -> cli
  # as well as lubridate
  devtools::load_all()
#+end_src

*** SOME reduce dependencies
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 12:23]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-31 Fri 12:23]
:END:

*** set the version
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:32]
:header-args:R: :tangle R/globals.R
:END:
#+begin_src R
 VER <- "snvec.r VERSION: 3.7.5 2023-03-29"
#+end_src

#+RESULTS:

*** global variables
:PROPERTIES:
:header-args:R: :tangle R/globals.R
:END:
#+begin_src R
  AU <- 1.49597870700e11 # m
  GM <- 1.32712440041e20 # m3/s2
  OM <- 7.292115e-5      # 1/s EarthRot
  R0 <- 3.8440e8         # m Moon R0
  GK <- 0.9925194        # Kinoshita75,77
  ED0 <- 0.0032738134    # DynEll (C-A)/C
  FGP <- 0.99961908
  AU3 <- AU * AU * AU
  R03 <- R0 * R0 * R0
  # no need to define pi in R
  R2D <- 180. / pi       # radians to deg

  D2S <- 3600. * 24.
  Y2D <- 365.25
  KY2D <- 1.e3 * Y2D

  # set default Ed, Td
  ED <- 1.0000         # set factor 1.0
  TD <- 0.0000         # set factor 0.0

  # mass ratios
  MSEL <- 328900.5596      # MS/(ME+ML)
  MEL <- 81.300568         # ME/ML
  MLS <- 1. / (MSEL * (1 + MEL)) # ML/MS
  # K0, beta0 for torques
  K0 <- (3. / 2.) * GM * ED0 * ED / (OM * AU3)
  K0D <- K0 * D2S          # 1/s => 1/d */
  BET0 <- GK * MLS * AU3 / R03
  K0B0 <- K0D * (1. + BET0)
  # Moon mean motion
  N0 <- sqrt(GM / MSEL / R03)
  NW0 <- (N0 / OM) # ratio (n/om)_0
  # Tidal dissipation Quinn91 Eqs. (3, 11)
  # NDN = (dndt/n)_0, WDW = (domdt/om)_0
  NDN <- (-4.6e-18 * D2S * TD) # 1/s => 1/d
  WDW <- (51. * NDN * NW0)     # Lambeck80
  # tidal effect on obliquity
  UEPSDOT <- -4.17e-19

  # SunRot Angles (Transform to HCI)
  OMT <- 75.5940
  INCT <- 7.155
  EP0 <- 23.439291111111110 # Obliquity t0
#+end_src

#+RESULTS:
: 23.4392911111111

** read in the orbital solution ZB18a
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:header-args:R: :tangle data-raw/ZB18a.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
*** notes on how to include data in an R package
see https://r-pkgs.org/data.html for how to include data in an R package
Generally, package data should be smaller than a megabyte - if itâ€™s larger youâ€™ll need to argue for an exemption. This is usually easier to do if the data is in its own package and wonâ€™t be updated frequently, i.e. if you approach this as a dedicated â€œdata packageâ€.
*** for our use-case, the file is
[[file:snvec-3.7.5/ems-plan3.dat]]

the top of the file has some lines specifying which columns were used
0  7  8  9  12 10 11 15

#+begin_src R :results value :colnames yes
  library(readr)

  dat <- read_table("snvec-3.7.5/ems-plan3.dat",
                    comment = "#",
                    skip = 3,
                    col_names = c(
                      "time",              # 0-Time (=Epoch)
                      ## "x1", "x2", "x3", # 1-3
                      ## "v1", "v2", "v3", # 4-6
                      "semimajor_axis",    # 7-SemiMajorAxis
                      "eccentricity",      # 8
                      "inclination",       # 9
                      "long_periapse",     # 12
                      ## "time_periapse",  # 13
                      "long_ascend_node",  # 10
                      "arg_periapse",      # 11
                      ## "peri_distance",  # 12
                      "mean_anomaly"#      # 15
                      ## "true_anomaly",   # 16
                      ## "mean_longitude", # 17
                      ## "true_longitude", # 18
                      ## "mean_latitude",  # 19
                      ## "true_latitude",  # 20
                      ## "mass",           # 21
                      ## "enc_radius",     # 22
                      ## "capt_radius",    # 23
                      ## "id_tag",         # 24
                      ## "jac_index"       # 25
                    ))

  head(dat) |> round(2)
#+end_src

#+RESULTS:
|    time | semimajor_axis | eccentricity | inclination | long_periapse | long_ascend_node | arg_periapse | mean_anomaly |
|---------+----------------+--------------+-------------+---------------+------------------+--------------+--------------|
|       0 |              1 |         0.02 |        7.15 |         27.32 |              180 |      -152.68 |        -2.45 |
| -146100 |              1 |         0.02 |        7.15 |         26.12 |          -179.59 |      -154.29 |         1.27 |
| -292200 |              1 |         0.02 |        7.14 |         24.69 |          -179.17 |      -156.14 |         5.22 |
| -438300 |              1 |         0.02 |        7.12 |         23.67 |          -178.75 |      -157.58 |         8.75 |
| -584400 |              1 |         0.02 |        7.11 |         22.12 |          -178.34 |      -159.54 |         12.8 |
| -730500 |              1 |         0.02 |         7.1 |            21 |          -177.92 |      -161.08 |        16.45 |

*** rename some of the names in dat
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:14]
:END:
to make the naming consistent with the C code
#+begin_src R
  dat <- dat |>
    tidylog::rename(
      t  = time,
      aa = semimajor_axis,
      ee = eccentricity,
      inc = inclination,
      lph = long_periapse,
      lan = long_ascend_node,
      arp = arg_periapse,
      mna = mean_anomaly)
#+end_src

#+RESULTS:

*** calculate the unwraps for lph and lan
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:03]
:END:
unwrap lph, lan
#+begin_src R
  dat <- dat |>
    mutate(lphu = unwrap(lph),
           lanu = unwrap(lan))
#+end_src

#+RESULTS:

**** inspect the unwrap
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 13:18]
:END:

#+begin_src R :results output graphics file :file imgs/test-unwrap.png :eval never :tangle no
  dat |>
    filter(age < 500) |>
    ggplot(aes(x = age, y = lph)) +
    scale_x_reverse() +
    geom_line() +
    geom_line(aes(y = lphu), col = "red")
#+end_src

#+RESULTS:
[[file:imgs/test-unwrap.png]]

*** calculate helper parameters
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fvei()][fvei()]]
helper parameters as new columns of dat
#+begin_src R
  dat <- dat |>
    mutate(age = - t / KY2D, .after = t) |>
    mutate(hh = ee * sin(lph / R2D),
           kk = ee * cos(lph / R2D),
           pp = 2 * sin(0.5 * inc / R2D) * sin(lan / R2D),
           qq = 2 * sin(0.5 * inc / R2D) * cos(lan / R2D),
           cc = cos(inc / R2D),
           dd = cos(inc / R2D / 2),
           ## /* nn <- nvec(t): normal to orbit */
           nnx = sin(inc / R2D) * sin(lan / R2D),
           nny = -sin(inc / R2D) * cos(lan / R2D),
           nnz = cos(inc / R2D))
#+end_src

#+RESULTS:

*** save the data
#+begin_src R
  ZB18a <- dat
  usethis::use_data(ZB18a, overwrite = TRUE, version = 3,
                    ## compress = "bzip2" # 13M
                    ## compress = "gzip" # 14M
                    compress = "xz" # 12M
                    )
#+end_src

#+RESULTS:
: [32mâœ”[39m Saving [34m'ZB18a'[39m to [34m'data/ZB18a.rda'[39m
: [31mâ€¢[39m Document your data (see [34m'https://r-pkgs.org/data.html'[39m)
*** document the data
#+begin_src R :tangle R/data.R
  #' Astronomical Solution from Zeebe et al., 2018
  #'
  #' The HNBody output of [@cite:Zeebe2018].
  #'
  #' The wikipedia page on [Orbital elements](https://en.wikipedia.org/wiki/Orbital_elements)
  #' describes what the components relate to to uniquely specify an orbital plane.
  #'
  #' @format ## `ZB18a`
  #' A data frame with 250,001 rows and 8 columns:
  #' \describe{
  #'   \item{t}{Time in days.}
  #'   \item{age}{Age in thousands of years (kyr) before present.}
  #'   \item{aa}{Semimajor axis.}
  #'   \item{ee}{Eccentricity}
  #'   \item{inc}{Inclination}
  #'   \item{lph}{Long periapse}
  #'   \item{lan}{Long ascending node}
  #'   \item{arp}{Argument of periapse}
  #'   \item{mna}{Mean anomaly}
  #'   \item{hh}{helper hh}
  #'   \item{kk}{helper hk}
  #'   \item{pp}{helper pp}
  #'   \item{qq}{helper qq}
  #'   \item{cc}{helper cc}
  #'   \item{dd}{helper dd}
  #'   \item{nnx, nny, nnz}{Vector of Earth's orbit normal.}
  #' }
  #' @source <http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro.html>
  "ZB18a"
#+end_src

** input parameters of the final function/program
:PROPERTIES:
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
*** start the function
#+begin_src R
  ##' snvec
  ##'
  ##' This function computes precession and tilt/obliquity from an astronomical
  ##' solution input and parameter values for dynamical ellipticity and tidal
  ##' dissipation.
  ##'
  ##' @param tend [double(1)] The final timestep in -kyr. Defaults to -1000 years.
  ##' @param ed [double(1)] Dynamical ellipticity. Defaults to 1.0.
  ##' @param td [double(1)] Tidal dissipation. Defaults to 0.0.
  ##' @param orbital_solution [character(1)] The orbital solution to use. See details.
  ##' @param tres [double(1)] The output timestep resolution in kyr. Defaults to 0.4.
  ##' @param tolerance [double(1)] The numerical tolerance passed to deSolve::ode's rtol and atol.
  ##' @param quiet [logical(1)] Do not print diagnostics to terminal.
  ##' @return A tibble with all the computed results.
  ##'
  ##' @author Ilja J. Kocken and Richard E. Zeebe
  ##'
  ##' @details Currently only the "ZB18a" orbital solution is supported.
  ##'
  ##' @examples
  ##' # default call
  ##' snvec()
  ##'
  ##' # a quick one with few timesteps, low resolution, high tolerance
  ##' snvec(-1e2, 1, 0, orbital_solution = "ZB18a", tres = 1, tolerance = 1e-4)
  ##'
  ##' @export
  snvec <- function(tend = -1e3,
                    ed = 1,
                    td = 0,
                    orbital_solution = "ZB18a",
                    tres = 0.4,
                    tolerance = 1e-7,
                    quiet = FALSE) {
#+end_src

#+RESULTS:

*** set the inputs
#+begin_src R :tangle no
  ## ed <- 1
  ## td <- 0
  ## tend <- -1e3 # quick tester, defaults for C
  ## tend <- -1e5 # full solution
#+end_src

#+RESULTS:
*** check inputs
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 11:56]
:END:
**** select the desired orbital solution
#+begin_src R
  solutions <- c("ZB18a", "La11")
  if (!orbital_solution %in% solutions) {
    cli::cli_abort(c("{.var orbital_solution} must be one of: {.or {.q {solutions}}}",
                     "x" = "You've supplied {.q {orbital_solution}}"))
  }
  if (orbital_solution == "La11") {
    cli::cli_abort(c("Orbital solution: La11 currently not supported.",
                     "i" = "Pull requests welcome."))
  }
  if (orbital_solution == "ZB18a") {
    dat <- ZB18a
  }
#+end_src

**** tend
#+begin_src R
  if (tend >= 0) {
    cli::cli_abort(c("{.var tend} must be < 0",
                     "x" = "You've supplied {tend}"))
  }
  if (tend < min(dat$t / KY2D)) {
    cli::cli_abort(c("{.var tend} must be > the orbital solution {min(dat$t)/KY2D}",
                     "x" = "You've supplied {tend}"))
  }
#+end_src

#+RESULTS:

**** tres
a quick dumb input test for now
#+begin_src R
  if (abs(tres) < tend) {
    cli::cli_abort(c("|{.var tres}| must be < {.var tend}.",
                     "i" = "{.var tres} = {tres}",
                     "i" = "{.var tend} = {tend}"))
  }
#+end_src
*** message user about inputs
:PROPERTIES:
:CREATED:  [2023-03-28 Tue 13:31]
:END:
#+begin_src R
  if (!quiet) {
    startdate <- lubridate::now()
    cli::cli_inform(c(
           ## "This is {VER}",
           ## "Richard E. Zeebe",
           ## "Ilja J. Kocken",
           "Integration parameters:",
           "*" = "{.var tend} = {tend} kyr",
           "*" = "{.var ed} = {ed}",
           "*" = "{.var td} = {td}",
           "*" = "{.var orbital_solution} = {.q {orbital_solution}}",
           "*" = "{.var tres} = {tres} kyr",
           "*" = "{.var tolerance} = {tolerance}",
           "i" = "started at {.q {startdate}}"))
  }
#+end_src

#+RESULTS:
: This is snvec.r VERSION: 3.7.5 2023-03-29
: Richard E. Zeebe
: Ilja J. Kocken
: Integration parameters:
:  tend = -1e+05 kyr
:  Ed = 1
:  Td = 0

** COMMENT plot orbital solution input
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 14:20]
:END:
*** ee
#+begin_src R :results output graphics file :file imgs/input_ee.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = ee)) +
   labs(x = "Age (Ma)", y = "Eccentricity") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:imgs/input_ee.png]]

*** inc
#+begin_src R :results output graphics file :file imgs/input_inc.png :width 700 :eval never
  dat |>
   ggplot(aes(x = age / 1e3, y = inc)) +
   labs(x = "Age (Ma)", y = "Inclination") +
   scale_x_reverse() +
   geom_line()
#+end_src

#+RESULTS:
[[file:imgs/input_inc.png]]

*** lph
#+begin_src R :results output graphics file :file imgs/input_lph.png :width 700
  dat |>
   ggplot(aes(x = age / 1e3, y = lph)) +
   labs(x = "Age (Ma)", y = "Long Periapse") +
   scale_x_reverse() +
   xlim(c(1, 0)) +
   geom_line() +
   geom_line(aes(y = unwrap(lph)), col = "red") +
   coord_cartesian(ylim=c(-3.1e6,200))
#+end_src

#+RESULTS:
[[file:imgs/input_lph.png]]

*** lan
#+begin_src R :results output graphics file :file imgs/input_lan.png :width 700
  dat |>
   ggplot(aes(x = age / 1e3, y = lan)) +
   labs(x = "Age (Ma)", y = "Long Ascending Node") +
   scale_x_reverse() +
   xlim(c(1, 0)) +
   geom_line() +
   geom_line(aes(y = unwrap(lan)), col = "red") +
   coord_cartesian(ylim=c(-2e4, 5))
#+end_src

#+RESULTS:
[[file:imgs/input_lan.png]]

*** h, k, p, q
#+begin_src R :results output graphics file :file imgs/input_hkpq.png :width 700 :eval never
  dat |>
    select(age, hh, kk, pp, qq, cc, dd) |>
    pivot_longer(hh:dd) |>
    ggplot(aes(x = age / 1e3, y = value)) +
    labs(x = "Age (Ma)") +
    scale_x_reverse() +
    xlim(c(1, 0)) +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line()
#+end_src

#+RESULTS:
[[file:imgs/input_hkpq.png]]

** calculate global vars ndn, wdw, k0d from Td and Ed
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:40]
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fedtd() ][fedtd()]]
#+begin_src R
  # as a function of ed, td
  k0d <- ((3 / 2) * GM * ED0 * ed / (OM * AU3)) * D2S # 1/s => 1/d
  k0b0 <- k0d * (1 + BET0)
  ndn <- -4.6e-18 * D2S * td # 1/s => 1/d
  wdw <- 51 * ndn * NW0 # Lambeck80, see PTman
  tdg <- td # global Td
  dts <- dat$t[2] - dat$t[1] # difference in time
#+end_src

#+RESULTS:

*** the euler transformation
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 15:14]
:header-args:R: :tangle R/euler.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== euler()][euler()]]
#+begin_src R
  #' Euler transformation.
  #'
  #' s* = A * s, where spin vector s is in invariable plane and s* in instant
  #' orbit plane. inv = 1 gives inverse transformation (A^-1 = A' =
  #' transpose(A)).
  #'
  #' @param s The vector to be transformed.
  #' @param inc  The inclination.
  #' @param lan  The Long Ascending Node
  #' @param inv  Invert the output.
  euler <- function(s, inc, lan, inv = FALSE) {
    a <- matrix(c( cos(lan), sin(lan), 0,
                  -cos(inc) * sin(lan), cos(inc) * cos(lan), sin(inc),
                   sin(inc) * sin(lan), -sin(inc) * cos(lan), cos(inc)),
                 ncol = 3,
                 byrow = TRUE)
    if (inv) a <- t(a)
    a %*% s
  }
#+end_src

#+RESULTS:

*** initial values for the spin vector s
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:04]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== finits() ][finits()]]

use finits to get initial conditions in transformed ECLIPJ2000

#+begin_src R
  omt <- OMT / R2D
  inct <- INCT / R2D
  ep0 <- EP0 / R2D
  cs <- cos(ep0)

  # first row of nn -> needs to be a vector
  # orbit normal at t=0
  ninit <- dat |>
    filter(t == 0) |>
    select(nnx, nny, nnz) |>
    as.matrix() |>
    as.vector()

  # transform n => n'
  np <- euler(ninit, inct, omt, TRUE)

  # solve quadratic equation for s0'y
  a <- np[2] * np[2] + np[3]*np[3]
  b <- -2 * cs * np[2]
  c <- cs*cs - np[3] * np[3]

  s0p <- c(NA, NA, NA)
  s0p[2] <- (-b + sqrt(b*b-4*a*c))/(2*a)
  s0p[3] <- sqrt(1-s0p[2]*s0p[2])
  s0p[1] <- 0
  as.matrix(s0p)

  # transform s0' to s0
  s0 <- euler(s0p, inct, omt, 0)
#+end_src

#+RESULTS:
:           [,1]
: [1,] 0.0000000
: [2,] 0.3977784
: [3,] 0.9174815

*** set the deSolve state
#+begin_src R
  state <- c(sx = s0[1],
             sy = s0[2],
             sz = s0[3])
#+end_src

#+RESULTS:

*** define deSolve parameters
#+begin_src R
  parameters <- c(
    ed = ed,
    td = td,
    k0d = k0d,
    wdw = wdw,
    ndn = ndn)
#+end_src

#+RESULTS:

*** our inputs change as a function of time, so we need a function to describe them
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 09:06]
:header-args:R: :tangle R/interpolation.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== qinterp()][qinterp()]]

**** using approxfun
http://desolve.r-forge.r-project.org/ has an article on time-varying inputs
we can use approxfun to generate a function that approximates =col= for timestep t.

#+begin_src R
  ##' approxdat
  ##'
  ##' Linearly interpolate on a dataframe.
  ##'
  ##' @param dat The dataframe.
  ##' @param col The column we want to interpolate on.
  approxdat <- function(dat, col = ee) {
    # I'm not putting any input checks because it's an internal function
    dat |>
     select(t, {{col}}) |>
     approxfun(rule = 2)
  }
#+end_src

this is very slow though, so we use a quicker interpolation algorithm, closer
to how Richard does it in C.

**** implement qinterp similar to the C-routine
:PROPERTIES:
:header-args:R: :tangle R/interpolation.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
#+begin_src R
  ##' qinterp
  ##'
  ##' @param y The vector to interpolate.
  ##' @param ds The difference in timestep in the astronomical solution.
  ##' @param dx The difference between the current timestep and the timestep in the astronomical solution.
  ##' @param m The index variable of the current position in the astronomical solution.
  ##' @return The vector of interpolated results
  qinterp <- function(y, ds, dx, m) {
    yi <- y[m]; dy <- 0; dsa <- abs(ds); dxa <- abs(dx); mm <- 1L
    ## if (dxa > 0) {
      mm <- m - as.integer(sign(dx))
      dy <- y[mm] - y[m]
      yi <- yi + dy * dxa / dsa
    ## }
    return(yi)
  }
#+end_src

#+RESULTS:

**** double-check that the interpolation is working
#+begin_src R :eval never :tangle no
  input <- dat |>
    select(time, ee) |>
    approxfun(rule = 2)

  # this creates a function that we can call from within the other function
  # e.g.
  input(1.42 * KY2D)
#+end_src

#+RESULTS:
: [1] 0.01670545

> I created the approxfun function

#+begin_src R :results output graphics file :file imgs/qinterp_test.png :tangle no
  t <- -.45 * KY2D
  m <- min(round(abs(t / dts) + 1), nrow(dat))
  dx <- t - dat$t[m];

  dat |>
    slice(1:3) |>
    ggplot(aes(x = t, y = lph)) +
    geom_line() +
    geom_point() +
    annotate("point",
             x = t,
             ## y = qinterp(dat, lph)(-.45 * KY2D),
             y = qinterp(dat$lph, dts, dx, m),
             col = "red")
#+end_src

#+RESULTS:
[[file:imgs/qinterp_test.png]]

**** time how long it takes
#+begin_src R :results output graphics file :file imgs/benchmark_qinterp.png :width 800 :eval never :tangle no
  bm_qi <- microbenchmark::microbenchmark(
                  approxdat(dat, qq)(-146100),
                  qinterp(dat$qq,-146100,-48700,4)
                  )
  autoplot(bm_qi)
#+end_src

#+RESULTS:
[[file:imgs/benchmark_qinterp.png]]

yeah that's ... 4 orders of magnitude faster...

** solve the system of ODEs
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:11]
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:

*** the differential equations
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 11:56]
:END:
see [[derivs]]

#+begin_src R
  # derivatives. RHS of DEQs for spin vector s = y
  eqns <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {
      m <- min(round(abs(t / dts) + 1), nrow(dat))

      dx <- t - dat$t[m];
      qqi <- qinterp(dat$qq,dts,dx,m)
      ppi <- qinterp(dat$pp,dts,dx,m)
      cci <- qinterp(dat$cc,dts,dx,m)
      ddi <- qinterp(dat$dd,dts,dx,m)

      # 1/(1-e^2)^3/2 term
      # add interpolation
      ## hhi <- qinterp(dat$hh,dts,dx,m)
      ## kki <- qinterp(dat$kk,dts,dx,m)
      ## ff <- (1 - hhi * hhi - kki * kki)

      # shouldn't I also interpolate hh and kk? -> see above
      ff <- (1 - dat$hh[m] * dat$hh[m] - dat$kk[m] * dat$kk[m])
      # i've tried both, gives identical results if I use the prescribed timesteps.
      # they're also equally fast! so let's go with my own which I think is better.
      # it might be the cause of numerical diffs between C and R? try without again

      ff <- 1 / sqrt(ff*ff*ff)
      kb <- k0d * (1 + 1 * wdw * t) * (ff + BET0 * (1 + 2 * ndn * t))

      fac <- FGP * kb * (ddi * (ppi * sx - qqi * sy) + cci * sz)

      dX <-  fac * ( cci * sy + ddi * qqi * sz)
      dY <-  fac * (-cci * sx + ddi * ppi * sz)
      dZ <- -fac * ( qqi * sx + ppi * sy) * ddi

      # EPSDOT
      ## dotab = s[1]*nn[1][m]+s[2]*nn[2][m]+s[3]*nn[3][m];
      ## tmp = tdg*EPSDOT*D2S/sqrt(1.-dotab*dotab);
      ## yp[1] += tmp*(nn[1][m] - dotab*s[1]);
      ## yp[2] += tmp*(nn[2][m] - dotab*s[2]);
      ## yp[3] += tmp*(nn[3][m] - dotab*s[3]);

      list(c(dX, dY, dZ))
    }) # end 'with(as.list( ...
  }
#+end_src

#+RESULTS:


*** timesteps to report
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 14:08]
:END:

**** a linear sequence of steps
#+begin_src R
  ## EPSLVR <- 1.e-7 # accuracy 1e-7 2.2e-7/8.5e-7 La
  times <- seq(0, tend * KY2D,
               ## length.out = 2523L # the length of the C-output
               by = - tres * KY2D # ~ the average diff in the C-output
               # snv_sout$time |> diff() |> median() = 0.396013
               )
#+end_src

#+RESULTS:

**** let's use the exact same timesteps as the C-routine
[[file:~/SurfDrive/Postdoc1/prj/2023-03-23_snvec-R/README.org::*inspect the c output][inspect the c output]]

#+begin_src R :eval never :tangle no
  times <- snv_sout$time * KY2D
  # what if I offset it by a few steps?
  ## times <- times - 0.1 * KY2D
  # it gets offset again! :O
#+end_src

#+RESULTS:
*** solve it
[[file:snvec-3.7.5/snvec-3.7.5.c::%%% solver][odeint()]]
#+begin_src R
  print(system.time(
  ## microbenchmark::microbenchmark(
    out <- deSolve::ode(y = state,
               times = times,
               func = eqns,
               parms = parameters,
               method =
                 ## "lsoda"# = default, chooses stiff/nonstiff automatically starting non-stiff
                 # "ode23" # = non-stiff, variable time-step
                 ## "ode45" # = stiff, variable time-step
               # radau #= stiff/non-stiff
               "bdf", # = stiff
               ## "daspk", # = very stiff
               # play around with machine precision: default is 1e-6
               ## rtol = 1e-5, atol = 1e-5 # rougher = faster?
               rtol = tolerance, atol = tolerance # based on EPSLVR
               ## rtol = 1e-12, atol = 1e-12
               )
  ))
  ## )
#+end_src

#+RESULTS:
:    user  system elapsed
:  18.267   0.003  18.317

*** older results notes
| date             |     user |  system |  elapsed | method |  steps | notes                                |                           |
|------------------+----------+---------+----------+--------+--------+--------------------------------------+---------------------------|
| [2023-03-30 Thu] |  361.986 |   0.213 |  364.353 | rk4    |   1000 |                                      |                           |
| [2023-03-30 Thu] |  334.800 |   0.081 |  336.341 | rk4    |   1000 | no error                             |                           |
| [2023-03-31 Fri] | 2927.945 | 187.784 | 3136.222 | ode23  |   5001 | with interpolation of hh kk          |                           |
| [2023-04-01 Sat] | 3649.884 | 186.344 | 3853.946 | ode45  |   5001 |                                      |                           |
| [2023-04-01 Sat] |  366.281 |  13.585 |  381.437 | bdf    |   2523 | same number of steps as in C-routine |                           |
| [2023-04-02 Sun] |  320.980 |  12.352 |  334.679 | daspk  |   2523 |                                      |                           |
| [2023-04-02 Sun] |  792.366 |  26.664 |  824.907 | lsoda  |   2523 | default                              |                           |
| [2023-04-03 Mon] |  242.316 |  25.936 |  269.344 | daspk  |   2523 | qinterp closer to C                  |                           |
| [2023-04-03 Mon] |    0.181 |   0.000 |    0.182 | daspk  |   2523 | qinterp fix!                         |                           |
| [2023-04-03 Mon] |    0.128 |   0.001 |    0.128 | daspk  |   2523 | same timesteps as C                  |                           |
| [2023-04-03 Mon] |   15.517 |   0.000 |   15.556 | daspk  |   2501 | linear timestep + a/rtol = 1e-10     |                           |
| [2023-04-03 Mon] |    0.147 |   0.000 |    0.147 | bdf    |   2501 | flipped times                        |                           |
| [2023-04-03 Mon] |   29.969 |   0.000 |   30.073 | bdf    |   2501 | rtol = atol = 1e-12                  |                           |
| [2023-04-03 Mon] |   18.229 |   0.026 |   18.338 | bdf    | 250001 | bdf                                  | rtol = 1e-7, full 100 Myr |

#+begin_src R :tangle no
  lubridate::as.duration(c(0.147, 100, 500, 1000, 2000, 3000))
#+end_src

#+RESULTS:
: [1] "0.147s"                 "100s (~1.67 minutes)"   "500s (~8.33 minutes)"   "1000s (~16.67 minutes)" "2000s (~33.33 minutes)" "3000s (~50 minutes)"

*** benchmarks using microbenchmark
:  out <- ode(y = state, times = times, func = eqns, parms = parameters,      method = "bdf")
:       min       lq    mean   median       uq      max neval
:  130.6327 134.4619 143.1704 137.2702 142.9504 279.2405   100 # daspk
:  125.8702 133.1821 140.109  134.8777 139.3579 188.0364   100 # bdf
:  213.6866 226.2011 241.949 232.1017 249.3671 401.4864    100 # lsoda
:  702.615  712.545  883.7992 715.33  724.0765 12602.84    100 # ode45

*** COMMENT save the output
this is no longer needed now that I have implemented the fast qinterp algorithm and it solves it almost instantly
#+begin_src R :tangle no
  ## write_rds(out, "out/2023-03-30_out.rds") # rk4, 1000 steps
  ## write_rds(out, "out/2023-03-31_out.rds") # ode23 5001 steps, intended for non-stiff problems!
  ## write_rds(out, "out/2023-04-01_out-ode45.rds") # ode45 5001 steps
  ## write_rds(out, "out/2023-04-01_out-bdf.rds")   # bdf stiff 2523 steps
  ## write_rds(out, "out/2023-04-02_out-daspk.rds")    # daspk stiff 2523 steps
  ## write_rds(out, "out/2023-04-02_out-lsoda.rds")    # lsoda stiff 2523 steps
  ## write_rds(out, "out/2023-04-03_out-qinterp.rds")    # daspk 2523 steps but with qinterp closer to c-implementation (???)
  ## write_rds(out, "out/2023-04-03_out-qinterp2.rds")    # daspk 2523 qinterp fix
  ## write_rds(out, "out/2023-04-03_out-times.rds")    # daspk 2523 same timestep as C = IDENTICAL!
  ## write_rds(out, "out/2023-04-03_out-tol.rds")    # daspk 2523 atol rtol = 1e-10
  ## write_rds(out, "out/2023-04-03_out-tollow.rds")    # daspk 2523 atol rtol = 1e-10
  ## write_rds(out, "out/2023-04-03_out-bdf.rds")    # bdf 2523 atol rtol = 1e-10
  ## write_rds(out, "out/2023-04-03_out-works.rds")    # bdf 2501 time in different order
  ## write_rds(out, "out/2023-04-04_out-tol.rds")    # bdf 2501 rtol = atol = 1e-12
  write_rds(out, "out/2023-04-04_out-full.rds")    # bdf 250001 rtol = atol = 1e-7
#+end_src

#+RESULTS:

*** COMMENT read in the main result
#+begin_src R :eval never :tangle no
  out <- read_rds("out/2023-04-03_out-works.rds")
#+end_src

#+RESULTS:

** analyse the ODE solver for problems
:PROPERTIES:
:CREATED:  [2023-04-03 Mon 14:38]
:END:
#+begin_src R :tangle no
  diagnostics(out)
#+end_src

#+RESULTS:
#+begin_example

--------------------
lsode return code
--------------------

  return code (idid) =  2
  Integration was successful.

--------------------
INTEGER values
--------------------

  1 The return code : 2
  2 The number of steps taken for the problem so far: 250064
  3 The number of function evaluations for the problem so far: 311277
  5 The method order last used (successfully): 5
  6 The order of the method to be attempted on the next step: 5
  7 If return flag =-4,-5: the largest component in error vector 0
  8 The length of the real work array actually required: 58
  9 The length of the integer work array actually required: 23
 14 The number of Jacobian evaluations and LU decompositions so far: 12539

--------------------
RSTATE values
--------------------

  1 The step size in t last used (successfully): -8.504139e-06
  2 The step size to be attempted on the next step: -8.504139e-06
  3 The current value of the independent variable which the solver has reached: -3.6525e+10
  4 Tolerance scale factor > 1.0 computed when requesting too much accuracy: 0
#+end_example

** COMMENT read in previous results
#+begin_src R :eval never :tangle no
  make_combinable <- function(dat, method) {
    dat |>
     as_tibble() |>
     mutate(across(time:sz, as.double)) |>
     mutate(method = method)
  }
#+end_src

#+RESULTS:

#+begin_src R :eval never :tangle no
  ## out <- read_rds("out/2023-03-29_out.rds")
  rk4 <- read_rds("out/2023-03-30_out.rds") |> make_combinable("rk4") # rk4, 1000 steps
  ode23 <- read_rds("out/2023-03-31_out.rds") |> make_combinable("ode23")# ode23 5001 steps, intended for non-stiff problems!
  ode45 <- read_rds("out/2023-04-01_out-ode45.rds") |> make_combinable("ode45") # ode45 5001 steps
  bdf <- read_rds("out/2023-04-01_out-bdf.rds") |> make_combinable("bdf")     # bdf stiff 2523
  daspk <- read_rds("out/2023-04-02_out-daspk.rds") |> make_combinable("daspk")     # stiff 2523
  lsoda <- read_rds("out/2023-04-02_out-lsoda.rds") |> make_combinable("lsoda")     # stiff 2523
#+end_src

#+RESULTS:

#+begin_src R :tangle no :eval never
  allout <- bind_rows(rk4, ode23, ode45, bdf, daspk, lsoda)
#+end_src

#+RESULTS:
: Error in list2(...) : object 'ode23' not found

** plot the output
and contrast to the C-results
this depends on snv_sout from [[file:~/SurfDrive/Postdoc1/prj/2023-03-23_snvec-R/README.org::*inspect the c output][inspect the c output]]

*** read in the raw spin vector s from the C-routine
the raw spin vector s, added as something that we write to file myself (not sure if correct!)
#+begin_src R
  snv_sout <- read_table("snvec-3.7.5/s-out.dat",
                        col_names = c("time", "sx", "sy", "sz", "x")) |>
    # this is because there's some whitespace there?
    # note that t is in tmv / KY2D = in kyr
    select(-x)
#+end_src

#+RESULTS:
:
: [36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
: cols(
:   time = [32mcol_double()[39m,
:   sx = [32mcol_double()[39m,
:   sy = [32mcol_double()[39m,
:   sz = [32mcol_double()[39m,
:   x = [33mcol_logical()[39m
: )


*** plot the spin vector s together with the C-routine for easy inspection
#+begin_src R :results output graphics file :output graphics file :file imgs/2023-03-29_output.png :width 700
  comb <- snv_sout |>
    mutate(code = "C") |>
    bind_rows(
      out |>
      as_tibble() |>
      select(time, sx, sy, sz) |>
      mutate(time = time / KY2D) |>
      mutate(code = "R") |>
      mutate(across(time:sz, as.numeric)))


  pl_s <- comb |>
    pivot_longer(cols = sx:sz) |>
    ggplot(aes(x = time, y = value, colour = name, linetype = code)) +
    geom_line() +
    geom_point() +
    annotate("rug",
             y = c(0.404360548210294,
                   -0.053622586775944,
                   0.913026378223150),
             sides = "l",
             colour = scales::hue_pal()(3),
             length = grid::unit(1, "cm"))
  pl_s
#+end_src

#+RESULTS:
[[file:imgs/2023-03-29_output.png]]

**** SOME make a plot of the difference between the two
:LOGBOOK:
- State "SOME"       from              [2023-04-04 Tue 11:15]
:END:
but they're not on the same timesteps so that would be annoying...

*** make the figure interactive in the browser
#+begin_src R :eval never
  plotly::toWebGL(plotly::ggplotly(pl_s, dynamicTicks = TRUE))
#+end_src

#+RESULTS:
: There were 15 warnings (use warnings() to see them)

** COMMENT plot the different methods
:PROPERTIES:
:CREATED:  [2023-04-02 Sun 11:24]
:END:
the different methods (other then timestep) result in identical results!!

#+begin_src R :results output graphics file :output graphics file :file imgs/2023-04-02_all-output.png :width 700 :eval never
  allout |>
    pivot_longer(cols = sx:sz) |>
    ggplot(aes(x = time, y = value, colour = name, linetype = method)) +
    geom_line() +
    geom_point() +
    annotate("rug",
             y = c(0.404360548210294,
                   -0.053622586775944,
                   0.913026378223150),
             sides = "r",
             colour = c("red", "green", "blue"),
             length = grid::unit(1, "cm")) +
   coord_cartesian(xlim = c(-20*KY2D, 0))
#+end_src

#+RESULTS:
[[file:imgs/2023-04-02_all-output.png]]

** print the final values for s
:PROPERTIES:
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
do we mean the value at time == 0? -> no! It's going back from 0 to -time
#+begin_src R
  fin <- out[nrow(out), ]
  ## fin <- out[1, ]
  u <- as.vector(c(fin[2], fin[3], fin[4]))

  if (!quiet) {
    cli::cli_inform(c(
           "Final values:",
           "*" = "s[1][2][3]: {paste(fin[2], fin[3], fin[4])}",
           "*" = "s-error = |s|-1: {sqrt(abs(pracma::dot(u, u)))-1}"))
  }
#+end_src

#+RESULTS:
: Error: object 'out' not found
: Error in as.vector(c(fin[2], fin[3], fin[4])) : object 'fin' not found
: Error: object 'quiet' not found

This is what it should look like compared to the C-routine:
for default settings

#+begin_example
@ Final values s[1][2][3]; s-error = |s|-1:
 0.404360548210294 -0.053622586775944  0.913026378223150
 1.046379e-09
#+end_example

for ./snvec.x -1e5 1.0 0.0
#+begin_example
@ Final values s[1][2][3]; s-error = |s|-1:
-0.334888085237340  0.020083244496882  0.942043775052535
 -7.977066e-08
#+end_example

** unwrap function
:PROPERTIES:
:header-args:R: :tangle R/unwrap.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== unwrap()][unwrap()]]
#+begin_src R
  #' unwrap angle.
  #'
  #' Unwrap angle. Maps jumps greater than pi to their 2pi complement.
  #'
  #' @param y Input vector in degrees.
  #' @return Unwrapped vector in degrees.
  unwrap <- function(y) {
    # let's stop being smart and just build it like Richard did in C
    cv <- rep(0, length(y)) # to make them the same length

    # vectorized ## dy <- diff(y) / R2D
    cx <- 0
    for(i in 2:length(y)){
      dy <- (y[i] - y[i-1]) / R2D # vectorized
      if(dy > pi){
        cx <- cx - 2.*pi
      } else
        if(dy < -pi){
          cx <- cx + 2.*pi
        }
      cv[i] <- cx
    }
    # ok I'll vectorize this one...
    yu <- y + cv*R2D
  }
#+end_src

#+RESULTS:

** interpolate the orbital solution
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:04]
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
back onto output timescale
#+begin_src R
  fin <- out |>
    as_tibble() |>
    mutate(
      age = -time / KY2D,
      nnx = approxdat(dat, nnx)(time),
      nny = approxdat(dat, nny)(time),
      nnz = approxdat(dat, nnz)(time),
      eei = approxdat(dat, ee)(time),
      inci = approxdat(dat, inc)(time),
      lphi = approxdat(dat, lphu)(time),
      lani = approxdat(dat, lanu)(time)
    )
#+end_src

#+RESULTS:

using qinterp in this case isn't faster because we need to apply it to the full record anyway
#+begin_src R :eval never :tangle no
  m = min(round(abs(time / dts)+1), nrow(dat)),
  dx = time - dat$t[m],
  age = -time / KY2D,
  nnx = qinterp(dat$nnx, dts, dx, m),
  nny = qinterp(dat$nny, dts, dx, m),
  nnz = qinterp(dat$nnz, dts, dx, m),
  eei = qinterp(dat$ee, dts, dx, m),
  inci = qinterp(dat$inc, dts, dx, m),
  lphi = qinterp(dat$lphu, dts, dx, m),
  lani = qinterp(dat$lanu, dts, dx, m)
#+end_src
** inspect C nni and unwrap output
#+begin_src R :eval never :tangle no
  cunwrap <- read_table("snvec-3.7.5/out-wrap.dat",
                        col_names = c("age", "nnx", "nny", "nnz", "lphu", "lanu", "x")) |>
    select(-x)
#+end_src

#+RESULTS:
#+begin_example

[36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
cols(
  age = [32mcol_double()[39m,
  nnx = [32mcol_double()[39m,
  nny = [32mcol_double()[39m,
  nnz = [32mcol_double()[39m,
  lphu = [32mcol_double()[39m,
  lanu = [32mcol_double()[39m,
  x = [33mcol_logical()[39m
)
#+end_example

#+begin_src R :results output graphics file :file imgs/test-nni-vs-C.png :eval never  :tangle no
  cunwrap |>
    ggplot(aes(x = age, y = nnx)) +
    geom_line() +
    geom_line(aes(x = -age), colour = "red", data = fin)
#+end_src

#+RESULTS:
[[file:imgs/test-nni-vs-C.png]]

#+begin_src R :results output graphics file :file imgs/test-unwrap-vs-C.png :eval never :tangle no
  dat |>
    filter(age > -1e3) |>
    ggplot(aes(x = -age, y = lph)) +
    geom_line() +
    # unwrapped data
    geom_line(aes(y = lphu), colour = "blue") +
    # interpolated data
    geom_line(aes(y = lphi), colour = "blue", data = fin) +
    xlim(c(-1e3, 0)) +
    ylim(c(-2e3, 2e2)) +
    geom_line(aes(x = age, y = lphu),
              data = cunwrap |>
                filter(age > -1e3),
              col = "red")
#+end_src

#+RESULTS:
[[file:imgs/test-unwrap-vs-C.png]]


** calculate obliquity
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:12]
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
#+begin_src R
  fin <- fin |>
    # calculate the dotproduct, richard's vvdot
    mutate(tmp = sx*nnx + sy*nny + sz*nnz,
           epl = acos(tmp))
#+end_src

#+RESULTS:

** COMMENT inspect c tmp and epl
#+begin_src R :eval never
  tmpepl <- read_table("snvec-3.7.5/out-tmp-epl.dat",
                        col_names = c("age", "tmp", "epl", "x")) |>
    select(-x)
#+end_src

#+RESULTS:
:
: [36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
: cols(
:   age = [32mcol_double()[39m,
:   tmp = [32mcol_double()[39m,
:   epl = [32mcol_double()[39m,
:   x = [33mcol_logical()[39m
: )

#+begin_src R :results output graphics file :file imgs/2023-04-04_test-tmp-epl.png :eval never
  tmpepl |>
    ggplot(aes(x = age, y = tmp)) +
    geom_line() +
    geom_line(aes(x = -age, y = tmp), colour = "red", data = fin)
#+end_src

#+RESULTS:
[[file:imgs/2023-04-04_test-tmp-epl.png]]

** calculate precession and climatic precession
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:14]
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
#+begin_src R
  fin <- fin |>
    # for each row, NOTE this makes it very slow!!
    rowwise() |>
    # create list columns of matrices
    # extract sx, sy, sz, and nnx, nny, nnz
    mutate(u = list(matrix(c(sx, sy, sz), ncol = 1, nrow = 3)),
           nv = list(matrix(c(nnx, nny, nnz), ncol = 1, nrow = 3)),
           # coords: fixed HCI => moving orbit plane
           up = list(euler(u, inci / R2D, lani / R2D, 0)),
           # coords: relative to phi(t=0)=0 at J2000
           up = list(euler(up, 0, -(lani + OMT) / R2D - pi / 2, 0)),
           # get 2nd and 1st column of up
           phi = map2_dbl(up[2, ], up[1, ], atan2)) |>
    ungroup() |>
    mutate(
           # normalize to first value of phi
           tmp = first(phi),
           phi = phi - tmp,
           cp = eei * sin((lphi + OMT) / R2D - phi),
           # phi is now mapped between 0 and 2 pi, whereas RZ's output is wrapped
           # between -pi and pi
           phi = ifelse(phi > pi, phi - 2*pi, phi)
           )
#+end_src

#+RESULTS:

*** DONE fix phi
CLOSED: [2023-04-04 Tue 12:30]
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 13:06]
:END:

** message user about final values
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:18]
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
#+begin_src R
  if (!quiet) {
    cli::cli_inform(
           c("Final values:",
             "*" = "obliquity: {fin[nrow(fin), 'epl']} rad",
             "*" = "precession: {fin[nrow(fin), 'phi']} rad",
             "i" = "stopped at {.q {lubridate::now()}}",
             "i" = "total duration:  {lubridate::as.duration(round(lubridate::now() - startdate, 2))}"))
  }
#+end_src

#+RESULTS:
: Final values obliquity, precession (rad):
: 0.389933827834007 1.98203205323792

for ./snvec.x -1e5 1.0 0.0
#+begin_example
@ Final values obliquity, precession (rad):
 0.391122130387012  3.068854702909980
#+end_example

** write output files
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 12:22]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-29 Wed 12:23]
:END:
for now write the rds output
#+begin_src R
  write_rds(fin, "out/2023-04-04_fin_full.rds")
#+end_src

#+RESULTS:

** end of the function
:PROPERTIES:
:header-args:R: :tangle R/snvec.R :comments org :session *R:snvec-R* :exports both :results output :eval no-export
:END:
#+begin_src R
   # return fin
   fin
  }
#+end_src

*** SOME make it possible to return out and quit early
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 17:01]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-04-04 Tue 17:02]
:END:
** plot final values
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 14:14]
:END:
*** epl
#+begin_src R :results output graphics file :file imgs/final_epl.png :width 700
  fin |>
   ggplot(aes(x = age, y = epl)) +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:imgs/final_epl.png]]

*** phi
#+begin_src R :results output graphics file :file imgs/final_phi.png :width 700
  fin |>
   ggplot(aes(x = age, y = phi)) +
   geom_hline(yintercept = c(-pi, pi), col = "red") +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:imgs/final_phi.png]]

*** cp
#+begin_src R :results output graphics file :file imgs/final_cp.png :width 700
  fin |>
   ggplot(aes(x = age, y = cp)) +
   geom_line() +
   geom_point() +
   scale_x_reverse()
#+end_src

#+RESULTS:
[[file:imgs/final_cp.png]]

* snvec.c
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
[[file:imgs/snvec-3.7.5/snvec-3.7.5.c]]

*** define global variables
once we turn this into a package, best to define them using a function
#+begin_src R
  ## def_globals <- function()
#+end_src

for now do it the simple way

#+RESULTS:

*** quick interpolation
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== qinterp()][qinterp()]]
not sure if needed, could just use R's interp?
#+begin_src R
  qinterp <- function(y, ds, dx, m) {
    yi <- y[m]
    dy <- 0.
    dsa <- abs(ds)
    dxa <- abs(x)
    mm <- 1L

    if (dxa > DBL_EPSILON) {
      mm <- m -
    }
  }
#+end_src

linear interpolation using approx
#+begin_src R
  x = c(41, 45, seq(48, 50, length.out = 8))
  y = rnorm(length(x), 0, 1)
  z = approx(x = x, y = y, xout = 41:50)$y

  plot(x, y, type = "o")
  points(41:50, z, col = "red", pch = 3)
#+end_src

#+RESULTS:
: [1m[33mError[39m in `tibble()`:[22m
: [1m[22m[33m![39m Tibble columns must have compatible sizes.
: [36mâ€¢[39m Size 10: Existing data.
: [36mâ€¢[39m Size 50: Column `z`.
: [36mâ„¹[39m Only values of size one are recycled.
: [90mRun `rlang::last_trace()` to see where the error occurred.[39m

#+begin_src R
    qinterp <- function(x) {
    approx(x = x, y = y, xout = )
  }
#+end_src
*** unwrap
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:38]
:END:
I used some help by chatgpt for the next few functions to explain the c-code
[[file:snvec-3.7.5/snvec-3.7.5.c::=== unwrap()][unwrap()]]
*** euler
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 14:39]
:END:
[[file:snvec-3.7.5/snvec-3.7.5.c::=== euler()][euler()]]

*** fvei
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fvei()][fvei()]]
calculates global h,k,p,q etc. from ecc,inc etc.

#+begin_src R
  #' fvei
  #'
  #' calculates global h,k,p,q etc. from ecc,inc etc.
  fvei <- function(ee, inc, lph, lan, ls) {
    hh <- ee * sin(lph / R2D)
    kk <- ee * cos(lph / R2D)
    pp <- 2. * sin(0.5 * inc / R2D) * sin(lan / R2D)
    qq <- 2. * sin(0.5 * inc / R2D) * cos(lan / R2D)
    cc <- cos(inc / R2D)
    dd <- cos(inc / R2D/2.)
    ## /* nn <- nvec(t): normal to orbit */
    nn[1] <-  sin(inc / R2D) * sin(lan / R2D)
    nn[2] <- -sin(inc / R2D) * cos(lan / R2D)
    nn[3] <-  cos(inc / R2D)
  }
#+end_src

for now put these values in a simple script below
*** finargs
[[file:snvec-3.7.5/snvec-3.7.5.c::=== finargs()][finargs()]]
 parse input arguments. arg list:
 [1] tend
 [2] Ed
 [3] Td
 [4] dir  OrbitSoln
 [5] file OrbitSoln

*** fedtd
[[file:snvec-3.7.5/snvec-3.7.5.c::=== fedtd() ][fedtd()]]
calculates global vars ndn,wdw,k0d from Td,Ed

#+begin_src R
  # as a function of ed, td
  k0d <- ((3./2.)*GM*ED0*ed/(OM*AU3))*D2S # 1/s => 1/d
  k0b0 <- k0d*(1.+BET0)
  ndn <- -4.6e-18*D2S*td # 1/s => 1/d
  wdw <- 51.*ndn*NW0 # Lambeck80, see PTman
  tdg <- td # global Td
#+end_src

#+RESULTS:
: Error: object 'ed' not found
: Error: object 'k0d' not found
: Error: object 'td' not found
: Error: object 'ndn' not found
: Error: object 'td' not found

*** finits
[[file:snvec-3.7.5/snvec-3.7.5.c::=== finits() ][finits()]]
init spin vector, transform to HCI
s,n in HCI. s',n' in ECLIPJ2000

calculates np
s0p
via euler transform

*** derivs
[[file:snvec-3.7.5/snvec-3.7.5.c::=== derivs()][derivs()]]

derivatives. RHS of DEQs for spin vector s = y

uses quinterp
#+begin_src R
  derivs <- function(t, y, yp) {
    kb <- ...
    ...
  }
#+end_src

yp[1]
yp[2]
yp[3] are the differential equations

qq pp = g-modes and s-modes, direct
cp derivs of h and k,
h and k from g-modes, calculate from ecc and long perihelion

these are prepped in fvei
*** driver
this is the one we want to study that does all the steps!

[[file:snvec-3.7.5/snvec-3.7.5.c::=== driver()][driver()]]
driver routine solving DEQs for spin vector s = y.

this calls =odeint=

odeint(y0,NEQ,t0,tfin,EPSLVR,h1,hmin,&nok,&nbad,derivs,stiff);

where y0 = a vector of size 3 (simple matrix)
NEQ = 3
t0 = 0.0
tfin = tfink * KY2D # days negative
  tfink =  tend = TEND = -1e3 (see finargs)
EPSLVR = 1e-7 global solver control
h1 = 0.1*dxsav
  dxsav = (tfin - t0)/kmax
  kmax = floor(1000.*2.656*sckx)
  sckx = fabs(tfink/1e3)
hmin = 0.0
&nok = ??
&nbad = ??
derivs = function(t, *y, *yp)
stiff = ??

*** odeint
[[file:imgs/snvec-3.7.5/fun/solver.c]]
Runge-Kutta driver. calls derivs and SOLVER.
Runge-Kutta driver with adaptive stepsize control. Integrate starting
values ystart[1..nvar] from x1 to x2 with accuracy eps, storing
intermediate results in global variables. h1 should be set as a
guessed first stepsize, hmin as the minimum allowed stepsize (can be
zero). On output nok and nbad are the number of good and bad (but retried
and fixed) steps taken, and ystart is replaced by values at the end of
the integration interval. derivs is the user-supplied routine for
calculating the right-hand side derivative, while SOLVER is the name
of the stepper routine to be used.

*** write outputs
*** [#A] inspect the C output
**** read in the raw spin vector s
the raw spin vector s, added as something that we write to file myself (not sure if correct!)
#+begin_src R
  snv_sout <- read_table("snvec-3.7.5/s-out.dat",
                        col_names = c("time", "sx", "sy", "sz", "x")) |>
    # this is because there's some whitespace there?
    # note that t is in tmv / KY2D = in kyr
    select(-x)
#+end_src

#+RESULTS:
:
: [36mâ”€â”€[39m [1mColumn specification[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
: cols(
:   time = [32mcol_double()[39m,
:   sx = [32mcol_double()[39m,
:   sy = [32mcol_double()[39m,
:   sz = [32mcol_double()[39m,
:   x = [33mcol_logical()[39m
: )

**** plot the raw spin vector s
#+begin_src R :results output graphics file :file imgs/c-output_s.png :width 700
  pl_refs <- snv_sout |>
    pivot_longer(cols = sx:sz) |>
    ggplot(aes(time, value, col = name)) +
    ## facet_grid(rows = vars(name), scales = "free_y") +
    ## scale_x_reverse() +
    geom_line() +
    ## geom_point() +
    # fix the xlim so that when we add other data it doesn't rescale
    xlim(c(-1e3, 0))
  pl_refs
#+end_src

#+RESULTS:
[[file:imgs/c-output_s.png]]

**** read the final eccentricity, phi, precession
#+begin_src R :results none
  snv_out <- read_table("snvec-3.7.5/out.dat",
                        col_names = c("t", "epl", "phi", "cp", "x")) |>
    # this is because there's some whitespace there?
    # note that t is in tmv / KY2D = in kyr
    select(-x)
#+end_src

**** plot the final eccentricity, phi, precession
#+begin_src R :results output graphics file :file imgs/c-output_ee.png :width 700
  pl_ref <- snv_out |>
    pivot_longer(cols = epl:cp) |>
    ggplot(aes(- t / KY2D / 1e3, value)) +
    facet_grid(rows = vars(name), scales = "free_y") +
    scale_x_reverse() +
    geom_line() +
    labs(x = "Age (Ma)")
    ## geom_point() +
    # fix the xlim so that when we add other data it doesn't rescale
    ## xlim(c(-1e3, 0))
  ## pl_ref
#+end_src

#+RESULTS:
[[file:imgs/c-output_ee.png]]

**** plot a histogram of the timesteps in the C-output
#+begin_src R :results output graphics file :file imgs/c-output_dt.png :width 700
  snv_out |>
    mutate(dt = t - lag(t)) |>
    ggplot(aes(dt)) +
    geom_histogram(binwidth = 0.001)
#+end_src

#+RESULTS:
[[file:imgs/c-output_dt.png]]

*** debug specific functions
[[file:snvec-3.7.5/snvec-3.7.5.c::Ilja's debugging scheme][Ilja's debugging scheme]]
* inspect deSolve package
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 12:02]
:END:
https://cran.r-project.org/package=deSolve
the implicit Runge-Kutta method RADAU (Hairer and Wanner 2010). The package contains also a de novo implementation of several Runge-Kutta methods (Butcher 1987; Press et al. 1992; Hairer, Norsett, and Wanner 2009).

** DONE calculate precession and obliquity/tilt based on values for \(E_{d}\) and \(T_{d}\)
CLOSED: [2023-03-29 Wed 14:09]
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
** SOME make the output easily accessible as well
:PROPERTIES:
:CREATED:  [2023-03-23 Thu 11:46]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-03-24 Fri 13:59]
:END:
** DONE what are the parameters that are needed for the differential equations?
CLOSED: [2023-03-29 Wed 12:01]
:PROPERTIES:
:CREATED:  [2023-03-24 Fri 13:54]
:END:
** reproduce their C-implementation that uses an input
:PROPERTIES:
:CREATED:  [2023-03-30 Thu 11:30]
:END:
[[file:imgs/~/Downloads/compiledCode.pdf::25]]

#+begin_src R
  library(deSolve)
  SPCmod <- function(t, x, parms, input) {
    with(as.list(c(parms, x)), {
      import <- input(t)
      dS <- import - b * S * P + g * C # subtrate
      dP <- c * S * P - d * C * P      # producer
      dC <- e * P * C - f * C          # consumer
      res <- c(dS, dP, dC)
      list(res, signal = import)
    })
  }

  parms <- c(b = .1, c = .1, d = .1, e = .1, f = .1, g = 0)

  times <- seq(0, 100, .1)
  signal <- as.data.frame(list(times = times,
                               import = rep(0, length(times))))
  signal$import <- ifelse((trunc(signal$times) %% 2 == 0), 0, 1)
  sigimp <- approxfun(signal$times, signal$import, rule = 2)

  xstart <- c(S = 1, P = 1, C = 1)
  print(system.time(
    out <- ode(y = xstart, times = times,
               func = SPCmod, parms, input = sigimp)
  ))
  plot(out)
#+end_src
* compare c and R output
:PROPERTIES:
:CREATED:  [2023-03-31 Fri 10:24]
:END:
** read in previous runs
#+begin_src R
  tol_1e07 <- read_rds("out/2023-04-04_normtol_1e-7.rds") |>
    mutate(tol = 1e-07) |>
    mutate(across(c(time, sx, sy, sz, age, epl), as.numeric))
  tol_1e10 <- read_rds("out/2023-04-04_lowtol.rds") |>
    mutate(tol = 1e-10) |>
    mutate(across(c(time, sx, sy, sz, age, epl), as.numeric))
  tol_1e12 <- read_rds("out/2023-04-04_superlowtol_1e-12.rds") |>
    mutate(tol = 1e-12) |>
    mutate(across(c(time, sx, sy, sz, age, epl), as.numeric))
  tol_1e03 <- read_rds("out/2023-04-05_hightol_1e-3.rds") |>
    mutate(tol = 1e-03) |>
    mutate(across(c(time, sx, sy, sz, age, epl), as.numeric))
#+end_src

#+RESULTS:

** create plot
#+begin_src R
  ## pl_both_young
  pl_both <- pl_ref +
    geom_line(aes(x = time / KY2D),
              data = lowtol |>
                select(time, tmp, epl, phi, cp) |>
                mutate(epl = as.double(epl)) |>
                pivot_longer(cols = c(epl, phi, cp)),
              col = "red") #+
  pl_both_young <- pl_both + xlim(c(-1e3, 0))
  pl_both_mid <- pl_both + xlim(c(-6.6e4, -6.5e4))
  pl_both_old <- pl_both + xlim(c(-1e5, -9.9e4))
#+end_src

#+RESULTS:
: Error in select(lowtol, time, tmp, epl, phi, cp) :
:   object 'lowtol' not found
: Error: object 'pl_both' not found
: Error: object 'pl_both' not found
: Error: object 'pl_both' not found

#+begin_src R :results output graphics file :file imgs/compare_c-R.png :width 700
  ## pl_both_young
  pl_both_mid
#+end_src

#+RESULTS:
[[file:imgs/compare_c-R.png]]
** interpolate C-output onto R grid and calculate differences
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 13:41]
:END:
#+begin_src R
  comp <- bind_rows(
    # combine all tolerance experiments
    tol_1e03,
    tol_1e07,
    tol_1e10,
    tol_1e12
  ) |>
    mutate(
      # add the interpolated C-output
      C_epl = approxdat(snv_out, epl)(-age),
      C_phi = approxdat(snv_out, phi)(-age),
      C_cp = approxdat(snv_out, cp)(-age),
      ) |>
    mutate(
      # calculate differences
      epl_diff = epl - C_epl,
      phi_diff = phi - C_phi,
      cp_diff = cp - C_cp,
      # calculate difference as a fraction of the max value
      epl_pc = epl_diff / max(epl),
      phi_pc = phi_diff / max(phi),
      cp_pc = cp_diff / max(cp)
    )
#+end_src

#+RESULTS:

#+begin_src R
  ## pl_diff_young
  breaks_fun <- function(x, big = TRUE) {
    if (max(x) > 6.2) { # phi_diff
        out <- seq(-3, 6, 3)
    } else if (max(x) > 0.04) { # cp_diff
        out <- seq(-0.060, 0.060, 0.03)
    } else if (max(x) > 0.015) { # epl_diff
        out <- seq(-0.02, 0.02, 0.01)
    }
    if (!big) {
      out <- seq(min(out),max(out), diff(out)[1]/10)
    }
    out
  }

  pl_diff <- comp |>
    # absolute diffs
    pivot_longer(ends_with("_diff")) |>
    # diff / max(x)
    ## mutate(epl_pc = as.double(epl_pc)) |>
    ## pivot_longer(ends_with("_pc")) |>
    ggplot(aes(x = age / 1e3, y = value, col = factor(tol))) +
    geom_line() +
    facet_grid(rows = vars(name), scales = "free_y") +
    labs(y = "R - C") +
    scale_y_continuous(breaks = breaks_fun, minor_breaks= ~breaks_fun(.x, FALSE))
    ## scale_y_continuous(breaks = seq(0,100,1), minor_breaks=seq(-100,100,0.1))

  pl_diff_old <- pl_diff + xlim(c(100, 99))
  pl_diff_mid <- pl_diff + xlim(c(66, 65))
  pl_diff_young <- pl_diff + xlim(c(1, 0))
  #+end_src

  #+RESULTS:

  #+begin_src R :results output graphics file :file imgs/compare_c-R-diff.png :width 700
    ## pl_diff_mid
    pl_diff_old
#+end_src

#+RESULTS:
[[file:imgs/compare_c-R-diff.png]]

#+begin_src R :results output graphics file :file imgs/compare_c-R-diff_hist.png :width 900
  comp |>
    pivot_longer(ends_with("_diff")) |>
    ggplot(aes(x = abs(value), fill = factor(tol))) +
    ## geom_density(alpha = .3) +
    ## geom_histogram(alpha = .3) +
    ## stat_summary(aes(y = 0), fun = mean_cl_normal) +
    ## ggridges::geom_density_ridges() +
    ggdist::stat_halfeye(aes(group = factor(tol),
                             ## colour = factor(tol)
                             ),
                         position = "dodge",
                         alpha = .4) +
    scale_x_sqrt() +
    ## scale_x_log10() +
    facet_grid(#rows = vars(factor(tol)),
               cols = vars(name),
               scales = "free", space = "free_y") +
    coord_cartesian(ylim = c(-.5, .6)) +
    theme(axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank()) +
    labs(fill = "Tolerance",
         x = "abs(diff) (note sqrt transform)")
#+end_src

#+RESULTS:
[[file:imgs/compare_c-R-diff_hist.png]]

#+begin_src R :results output graphics file :file imgs/compare_c-R-full_1e-10.png :width 1920 :height 1080
  library(patchwork)
  pl_both /
   (pl_both_old + pl_both_mid + pl_both_young) /
  pl_diff /
   (pl_diff_old + pl_diff_mid + pl_diff_young)
#+end_src

#+RESULTS:
[[file:imgs/compare_c-R-full.png]]

* tasks
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:27]
:END:
** DONE play around with the different ODE solver algorithms to figure out which one is fastest
CLOSED: [2023-04-04 Tue 09:28]
** DONE make the R routine visually return the same spin vector as the C routine
CLOSED: [2023-04-04 Tue 09:27]
** WAIT [12/12] make the R routine return machine precision close to identical results to the C routine
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:27]
:END:
:LOGBOOK:
- State "WAIT"       from "DONE"       [2023-04-05 Wed 11:02]
- State "DONE"       from "WAIT"       [2023-04-05 Wed 11:02]
- State "WAIT"       from "NEXT"       [2023-04-04 Tue 15:33]
- State "NEXT"       from "WAIT"       [2023-04-04 Tue 13:39]
- State "WAIT"       from "NEXT"       [2023-04-04 Tue 12:51]
:END:
- [X] hmm it's not the fact that in the C routine he doesn't interpolate the results for hh and kk
- [X] check for a long run if the error stays 1e-3 or if it accumulates -> it accumulates, see figs:
   [[file:imgs/2023-04-04_compare-c-to-R_56-54Ma.png]]
   [[file:imgs/2023-04-04_compare-c-to-R_81-78Ma.png]]
   [[file:imgs/2023-04-04_compare-c-to-R_100-97Ma.png]]
- [X] compare C-code to this with times
- almost good enough. For more direct comparison:
- [X] interpolate C results into R timegrid
- [X] calculate the difference
- [X] plot the difference
- [X] do the same for the full solar system solution
- [X] now do the long run but with a lower tolerance
  - [X] 1e-10
#+begin_src R
  lowtol <- snvec(-1e5, 1, 0, tolerance = 1e-10)
  write_rds(lowtol, "out/2023-04-04_lowtol.rds")
#+end_src

#+RESULTS:
: This is snvec.r VERSION: 3.7.5 2023-03-29
: Richard E. Zeebe
: Ilja J. Kocken
: Integration parameters:
:  tend = -1e+05 kyr
:  tres = 0.4 kyr
:  Ed = 1
:  Td = 0
: Final values s[1][2][3]; s-error = |s|-1:
: -0.164426067894575 0.406888350901304 0.898597654927192
: 3.59030270373761e-05
: Final values obliquity, precession (rad):
: 0.3899853310553 1.88486960858406

  - [X] 1e-12
#+begin_src R
  superlowtol <- snvec(-1e5, 1, 0, tolerance = 1e-12)
  write_rds(superlowtol, "out/2023-04-04_superlowtol_1e-12.rds")
#+end_src

#+RESULTS:
: This is snvec.r VERSION: 3.7.5 2023-03-29
: Richard E. Zeebe
: Ilja J. Kocken
: Integration parameters:
: tend = -1e+05 kyr
: tres = 0.4 kyr
: Ed = 1
: Td = 0
:     user   system  elapsed
: 3246.787    0.342 3255.612
: Final values s[1][2][3]; s-error = |s|-1:
: -0.143109361596917 0.419908122882867 0.896212779992251
: 2.34030537171748e-07
: Final values obliquity, precession (rad):
: 0.390596711702826 1.8189284314666

  - [X] 1e-7
#+begin_src R
  normtol <- snvec(-1e5, 1, 0, tolerance = 1e-7)
  write_rds(normtol, "out/2023-04-04_normtol_1e-7.rds")
#+end_src

#+RESULTS:
#+begin_example
Integration parameters:
 tend = -1e+05 kyr
 Ed = 1
 Td = 0
 orbital_solution = ZB18a
 tres = 0.4 kyr
 tolerance = 1e-07
starting at Wed Apr  5 09:55:48 2023
   user  system elapsed
 24.575   0.010  24.699
Final values s[1][2][3]; s-error = |s|-1:
-0.181186234717299 0.377666080230894 0.902100420308931
-0.00539189218589675
Final values obliquity, precession (rad):
0.389933827834007 1.96689170415452
stopped at Wed Apr  5 09:56:46 2023
#+end_example
- [X] 1e-3
#+begin_src R
  hightol <- snvec(-1e5, 1, 0, tolerance = 1e-3)
  write_rds(hightol, "out/2023-04-05_hightol_1e-3.rds")
#+end_src

#+RESULTS:
#+begin_example
Integration parameters:
 tend = -1e+05 kyr
 Ed = 1
 Td = 0
 orbital_solution = ZB18a
 tres = 0.4 kyr
 tolerance = 0.001
started at 2023-04-05 10:12:39
   user  system elapsed
 22.583   0.000  22.659
Final values s[1][2][3]; s-error = |s|-1:
-0.1069277059072 0.423122991463078 0.893789976171586
-0.00535075443649757
Final values obliquity, precession (rad):
0.392041645216932 1.72794012401827
stopped at Wed Apr  5 10:13:33 2023
total duration 54.119035243988
#+end_example

- [X] make the comparison between resolutions
** DONE [3/3] make the R routine return the same values for precession and obliquity
CLOSED: [2023-04-04 Tue 13:38]
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:29]
:END:
- [X] epl
- [X] cp
- [X] phi => there's something weird going on with the mapping to -pi to pi, but it works if I fix that manually
  rldpeace

** DONE make a function out of snvec so it's easy to vary Td and Ed
CLOSED: [2023-04-04 Tue 18:10]
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:28]
:END:
#+begin_src R
  ## devtools::load_all()
  test <- snvec(-1e3, 1, 0)
#+end_src

#+RESULTS:
#+begin_example
Integration parameters:
 tend = -1000 kyr
 Ed = 1
 Td = 0
 orbital_solution = ZB18a
 tres = 0.4 kyr
 tolerance = 1e-07
starting at Tue Apr  4 23:06:34 2023
   user  system elapsed
  0.211   0.000   0.213
Final values s[1][2][3]; s-error = |s|-1:
0.404197400723194 -0.0537088738295803 0.91303387030935
-5.44863786333671e-05
Final values obliquity, precession (rad):
0.413056573207875 -0.562236553023642
stopped at Tue Apr  4 23:06:35 2023
#+end_example

rldpeace

** WAIT calculate for grids of Td and Ed
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:29]
:END:
:LOGBOOK:
- State "WAIT"       from "DONE"       [2023-04-05 Wed 13:16]
:END:

*** create the desired grid for Td and Ed
:PROPERTIES:
:CREATED:  [2023-04-05 Wed 11:03]
:END:
#+begin_src R
  # same grid as in Zeebe & Lourens 2022 table 2: 10.1029/2021PA004349
  biggrid <- expand.grid(Td = c(0, 0.5, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2),
              Ed = c(1.000, 0.998, 1.005, 1.012)) |>
    # that's 32 rows
    as_tibble() |>
    # for now only for 1000 years so it's fast
    ## mutate(tol = 1e-4, tend = -1e3) |>
    # the real deal, full results at medium tolerance
    mutate(tol = 1e-7, tend = -1e5) |>
    # apply our new function!
    mutate(sol = pmap(list(td = Td, ed = Ed, tend = tend, tolerance = tol),
                      snvec))
  write_rds("out/biggrid.rds")

  # unnest the new list column
  expanded <- biggrid |>
    # must first make them all doubles because deSolve class doesn't have vctr attributes
    mutate(sol = map(sol,
                     ~ .x |> mutate(across(c(time, sx, sy, sz, age, epl), as.numeric)))) |>
    # then unnest it
    unnest(sol)
#+end_src

#+begin_src R :results output graphics file :file imgs/2023-04-05_experimental-grid_full.png :width 1920 :height 1080
  # then make a plot
  expanded |>
    ggplot(aes(x = age, y = cp,
               colour = factor(Td),
               linetype = factor(Ed))) +
    scale_x_reverse("Age (ka)", xlim = c(100, 99)) +
    ## facet_grid(rows = vars(Ed)) +
    facet_grid(rows = vars(Td)) +
    geom_line() +
    geom_line(aes(y = eei))
#+end_src

#+RESULTS:
[[file:imgs/2023-04-05_experimental-grid.png]]

#+begin_src R :results output graphics file :file imgs/2023-04-05_experimental-grid_phi.png :width 1920 :height 1080
  # then make a plot
  expanded |>
    ggplot(aes(x = age, y = phi,
               colour = factor(Td),
               linetype = factor(Ed))) +
    scale_x_reverse("Age (ka)") +
    ## facet_grid(rows = vars(Ed)) +
    facet_grid(rows = vars(Td)) +
    geom_line()
#+end_src

#+RESULTS:
[[file:imgs/2023-04-05_experimental-grid_phi.png]]

** NEXT visualize results: a heat map?
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 09:29]
:END:
for that I'd need to have the difference function with a record
** SOME make the La2011 solution obl + precession available?
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 10:35]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-04-04 Tue 10:36]
:END:
but NOT the 2004 solutions! divergence times at ~40 Ma with 2011 or ZB18a
** SOME check out the Wu paper / acycle
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 10:37]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-04-04 Tue 10:39]
:END:
they apply the Laskar fortran routine from 92/93 to calculate precession/obliquity for the La2011 but that's in the ecliptic reference plane rather than the intertial reference frame.
** SOME add a progress bar
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 18:23]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-04-04 Tue 18:23]
:END:
https://github.com/r-lib/progress#readme
** NEXT document all function parameters correctly
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 18:45]
:END:
https://style.tidyverse.org/documentation.html#documenting-parameters
** NEXT add return docs to each function
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 18:46]
:END:
** SOME make it possible for snvec to write to file
:LOGBOOK:
- State "SOME"       from              [2023-04-05 Wed 13:20]
:END:
add a file = NULL argument
at the end
#+begin_src R :eval never :tangle no
if(!is.null(file)) { readr::write_rds(fin, file = file) }
#+end_src
** docs tips from pkgs
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 18:48]
:END:
https://r-pkgs.org/man.html
** DONE write nice error messages in the tidyverse style
CLOSED: [2023-04-05 Wed 12:27]
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 18:44]
:END:
https://style.tidyverse.org/error-messages.html
and info messages
** SOME move the code out of here for reals -> pkg structure is single source of truth
:PROPERTIES:
:CREATED:  [2023-04-04 Tue 18:49]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-04-04 Tue 18:49]
:END:
